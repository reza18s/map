// File: src/uitils/index.ts

// File: src/app/providers.tsx
"use client";
import { NextUIProvider } from "@nextui-org/react";

export function Providers({ children }: { children: React.ReactNode }) {
  return <NextUIProvider>{children}</NextUIProvider>;
}

// File: src/app/layout.tsx
import { Inter } from "next/font/google";
import { Providers } from "./providers";
import "./globals.css";
import "../css/style.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata = {
  title: "Map",
  description: "Map Selector by shahyad karimi",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}

// File: src/app/api/polygons/update-flag/route.ts
import connectDB from "@/configs/db";
import PolygonsModel from "@/models/PolygonModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id, flag } = body;

    await PolygonsModel.findOneAndUpdate({ _id: id }, { $set: { flag } });

    return NextResponse.json({ message: "Flag updated!" });
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/polygons/route.ts
import connectDB from "@/configs/db";
import PolygonsModel from "@/models/PolygonModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB(); // Ensure the DB connection is correct
    const body = await req.json();
    const { name, points, flag } = body;

    if (!name || !points || !flag) {
      throw new Error("Missing required fields");
    }

    // Create a new polygon in the database
    const polygon = await PolygonsModel.create({
      name,
      points,
      flag,
      isPolygon: true,
    });

    return NextResponse.json(
      { message: "Polygon created successfully!", polygon },
      { status: 200 },
    );
  } catch (err) {
    console.error("Error creating polygon:", err);
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}

export async function GET() {
  try {
    await connectDB();
    const polygons = await PolygonsModel.find({ isPolygon: true, flag: 1 });
    return NextResponse.json(polygons);
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/settings/route.ts
import connectDB from "@/configs/db";
import SettingsModel from "@/models/SettingsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { lat, lng, zoom } = body;

    await SettingsModel.findOneAndUpdate(
      { _id: "66c3774a9757762530e4bfd1" },
      { $set: { lat, lng, zoom } },
    );

    return NextResponse.json(
      { message: "Point updated successfully!" },
      { status: 200 },
    );
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

export async function GET() {
  try {
    await connectDB();
    const settings = await SettingsModel.findOne(
      { _id: "66c3774a9757762530e4bfd1" },
      "-__v",
    );
    return NextResponse.json(settings);
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/points/route.ts
import connectDB from "@/configs/db";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { lat, lng, date, deletedAt, name, frequency } = body;

    const points = await PointsModel.create({
      lat,
      lng,
      date,
      name,
      frequency,
      deletedAt,
    });
    return NextResponse.json(
      { message: "Point created successfully!", points },
      { status: 200 },
    );
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

export async function GET() {
  try {
    await connectDB();
    const points = await PointsModel.find({ deletedAt: null }, "-__v");
    return NextResponse.json(points);
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

export async function DELETE(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id } = body;

    await PointsModel.findOneAndUpdate(
      { _id: id },
      { $set: { deletedAt: new Date() } },
    );
    return NextResponse.json({ message: "Point deleted successfully!" });
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/points/search/route.ts
import connectDB from "@/configs/db";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { search } = body;

    const points = await PointsModel.find({ name: search, deletedAt: null });
    return NextResponse.json(points);
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/points/update-point/route.ts
import connectDB from "@/configs/db";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { name, lat, lng, frequency, id } = body;

    await PointsModel.findOneAndUpdate(
      { _id: id },
      { $set: { name, lat, lng, frequency } },
    );
    return NextResponse.json({ message: "Point updated!" });
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/points/change-status/route.ts
import connectDB from "@/configs/db";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id } = body;

    const point = await PointsModel.findOne({ _id: id });
    await PointsModel.findOneAndUpdate(
      { _id: id },
      { $set: { status: point?.status === "active" ? "disable" : "active" } },
    );

    return NextResponse.json({ message: "Point status updated!" });
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/page.tsx
// File: src/app/page.tsx
"use client";
import dynamic from "next/dynamic";
import { useAppStore } from "@/store/store"; // Import the Zustand store
import { useEffect } from "react";

const Map = dynamic(() => import("@/components/map/Map"), {
  ssr: false,
});
const Sidebar = dynamic(() => import("@/components/sidebar/Sidebar"), {
  ssr: false,
});

export default function Home() {
  const {
    addPointModal,
    setAddPointModal,
    showPointList,
    setShowPointList,
    points,
    setPoints,
  } = useAppStore();

  useEffect(() => {
    // Fetch points data and update the store
    // Example: fetchPoints().then((data) => setPoints(data));
  }, []);

  return (
    <div className="flex h-screen w-full items-center">
      <Sidebar
        addPointModal={addPointModal}
        setAddPointModal={setAddPointModal}
        showPointList={showPointList}
        setShowPointList={setShowPointList}
      />
      <Map
        addPointModal={addPointModal}
        setAddPointModal={setAddPointModal}
        showPointList={showPointList}
        setShowPointList={setShowPointList}
        points={points}
      />
    </div>
  );
}

// File: src/app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

// File: src/helper/drawPolygon.ts
import { postData } from "@/services/API";

import L from "leaflet";
export const DrawPolygon = async (map: L.Map, callBack: () => void) => {
  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  const drawControl = new L.Control.Draw({
    draw: {
      //@ts-expect-error the
      polygon: true,
      marker: false,
      polyline: false,
      rectangle: false,
      circle: false,
      circlemarker: false,
    },
    edit: {
      featureGroup: drawnItems,
    },
  });

  map.addControl(drawControl);

  map.on(L.Draw.Event.CREATED, function (event: any) {
    const layer = event.layer;
    drawnItems.addLayer(layer);
    const latlngs = layer.getLatLngs()[0].map((latlng: L.LatLng) => ({
      lat: latlng.lat,
      lng: latlng.lng,
    }));
    const name = prompt("Enter a name for the polygon:");

    if (name) {
      return postData("/api/polygons", {
        name,
        points: latlngs,
        flag: 1,
      }).then(() => {
        callBack();
      });
    }
  });
};

// File: src/helper/controlSaveTiles.ts
import "leaflet.offline";
import "leaflet-draw";
import L from "leaflet";
export const controlSaveTiles = ({
  map,
  setProgress,
  setTotal,
}: {
  map: L.Map;
  setProgress: React.Dispatch<React.SetStateAction<number>>;
  setTotal: React.Dispatch<React.SetStateAction<number>>;
}) => {
  const tileLayerOffline = L.tileLayer.offline(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution:
        '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
      subdomains: "abc",
      minZoom: 11,
      maxZoom: 16,
    },
  );
  tileLayerOffline.addTo(map);
  const controlSaveTiles = L.control.savetiles(tileLayerOffline, {
    zoomlevels: [11, 12, 13, 14, 15, 16],
    confirm(layer: any, succescallback: () => void) {
      if (
        window.confirm(
          `Are you sure you want to download ${layer._tilesforSave.length} tiles?`,
        )
      ) {
        succescallback();
      }
    },
    confirmRemoval(layer: any, successCallback: () => void) {
      if (window.confirm("Are you sure you want to remove all tiles?")) {
        successCallback();
      }
    },
    saveText: `<div class="w-full h-full flex justify-center items-center">
  <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="currentColor"
      class="size-5"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
      />
    </svg>
  </div>`,
    rmText: `<div class="w-full h-full flex justify-center items-center">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="1.5"
        stroke="currentColor"
        class="size-5"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"
        />
      </svg>
    </div>`,
  });
  controlSaveTiles.addTo(map);

  let progress: number;
  tileLayerOffline.on("savestart", (e: any) => {
    progress = 0;
    setTotal(e._tilesforSave.length);
  });
  tileLayerOffline.on("savetileend", () => {
    progress += 1;
    setProgress(progress);
  });
};

// File: src/helper/helper.ts
export const dateFormatter = (
  date: {
    start: { day: number; month: number; year: number };
    end: { day: number; month: number; year: number };
  },
  time: { hour: number; minute: number },
) => {
  return {
    start: `${date.start.month}/${date.start.day}/${date.start.year} ${time.hour}:${time.minute}`,
    end: `${date.end.month}/${date.end.day}/${date.end.year} ${time.hour}:${time.minute}`,
  };
};

// File: src/helper/geometry.ts
// src/helper/geometry.ts

import { LatLng } from "leaflet";

// Haversine formula to calculate the distance between two LatLng points
export function getDistance(point1: LatLng, point2: LatLng): number {
  const R = 6371e3; // Radius of the earth in meters
  const φ1 = (point1.lat * Math.PI) / 180;
  const φ2 = (point2.lat * Math.PI) / 180;
  const Δφ = ((point2.lat - point1.lat) * Math.PI) / 180;
  const Δλ = ((point2.lng - point1.lng) * Math.PI) / 180;

  const a =
    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  const distance = R * c; // Distance in meters
  return distance;
}

// File: src/helper/offline.ts
/* global L, LeafletOffline, $ */

const urlTemplate = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";

// Show tile list function
function showTileList(): void {
  // @ts-expect-error the
  LeafletOffline.getStorageInfo(urlTemplate).then((r: any[]) => {
    const list = document.getElementById("tileinforows");
    if (list) {
      list.innerHTML = "";
      r.forEach((tile: any, i: number) => {
        const createdAt = new Date(tile.createdAt);
        list.insertAdjacentHTML(
          "beforeend",
          `<tr><td>${i}</td><td>${tile.url}</td><td>${tile.key}</td><td>${createdAt.toDateString()}</td></tr>`,
        );
      });
    }
  });
}

// @ts-expect-error the
$("#storageModal").on("show.bs.modal", showTileList);

// Initialize map and base layer
const map = L.map("map");
const baseLayer = L.tileLayer
  .offline(urlTemplate, {
    attribution: "Map data {attribution.OpenStreetMap}",
    subdomains: "abc",
    minZoom: 13,
  } as L.TileLayerOptions)
  .addTo(map);

// Set up tile saving controls
const control = L.control.savetiles(baseLayer, {
  zoomlevels: [13, 16],
  confirm: (layer: any, successCallback: () => void): void => {
    if (window.confirm(`Save ${layer._tilesforSave.length}`)) {
      successCallback();
    }
  },
  confirmRemoval: (layer: any, successCallback: () => void): void => {
    if (window.confirm("Remove all the tiles?")) {
      successCallback();
    }
  },
});

control.addTo(map);

// Set map view
map.setView({ lat: 51.985, lng: 5 }, 16);

// Add layers to map
const layerswitcher = L.control
  // @ts-expect-error the
  .layers({ "osm (offline)": baseLayer }, null, { collapsed: false })
  .addTo(map);

// GeoJSON storage layer
let storageLayer: L.GeoJSON;

// Get stored GeoJSON data
const getGeoJsonData = (): Promise<L.GeoJSON> =>
  // @ts-expect-error the
  LeafletOffline.getStorageInfo(urlTemplate).then((data: any) =>
    // @ts-expect-error the
    LeafletOffline.getStoredTilesAsJson(baseLayer, data),
  );

// Add storage layer to the map
const addStorageLayer = (): void => {
  getGeoJsonData().then((geojson: any) => {
    storageLayer = L.geoJSON(geojson).bindPopup(
      (clickedLayer: any) => clickedLayer.feature.properties.key,
    );
    layerswitcher.addOverlay(storageLayer, "stored tiles");
  });
};

addStorageLayer();

// Event listener to remove tiles
document.getElementById("remove_tiles")?.addEventListener("click", () => {
  (control as any)._rmTiles(); // Assuming _rmTiles is a method without typing in the library
});

// Update storage size event
baseLayer.on("storagesize", (e: any) => {
  document.getElementById("storage")!.innerHTML = e.storagesize.toString();
  if (storageLayer) {
    storageLayer.clearLayers();
    getGeoJsonData().then((data: any) => {
      storageLayer.addData(data);
    });
  }
});

// Progress tracking for saving tiles
let progress: number;
baseLayer.on("savestart", (e: any) => {
  progress = 0;
  document.getElementById("total")!.innerHTML =
    e._tilesforSave.length.toString();
});
baseLayer.on("savetileend", () => {
  progress += 1;
  document.getElementById("progress")!.innerHTML = progress.toString();
});

// File: src/store/useModal.ts
import { IPoint } from "@/types";
import React from "react";
import { create } from "zustand";
import { devtools } from "zustand/middleware";

export type ModalData = {
  point?: IPoint;
};
interface IModal {
  isLoading: boolean;
  data: ModalData;
  isOpen: boolean;
  modal: React.ReactNode;
}
export type Actions = {
  setOpen: (modal: React.ReactNode, data?: ModalData) => void;
  setClose: () => void;
  setIsLoading: (state: (() => boolean) | boolean) => void;
};
export type Store = IModal & Actions;
const defaultValues: IModal = {
  isLoading: false,
  data: {},
  modal: null,
  isOpen: false,
};
export const useModal = create<Store>()(
  devtools((set, get) => ({
    ...defaultValues,
    setOpen: (modal, data) => {
      set({ modal, isOpen: true, data: { ...get().data, ...data } });
    },
    setClose: () => {
      set(defaultValues);
    },
    setIsLoading: (state) => {
      if (typeof state == "boolean") {
        return set({ isLoading: state });
      }
      return set({ isLoading: state() });
    },
  })),
);

// File: src/store/store.ts
// File: src/store/store.ts
import { getData, postData } from "@/services/API";
import { IPoint, IPolygon, ISettings } from "@/types";
import { create } from "zustand";
import L from "leaflet";

interface dataType {
  map: L.Map | null;
  isLoading: boolean;
  points: IPoint[];
  polygons: IPolygon[]; // New state for polygons
  settings?: ISettings;
  addPointModal: boolean;
  showPointList: boolean;
}

interface storeAction {
  setAddPointModal: (value: boolean) => void;
  setShowPointList: (value: boolean) => void;
  setPoints: (points: IPoint[]) => void;
  setPolygons: (polygons: IPolygon[]) => void; // New setter for polygons
  getSettings: () => void;
  getAllPoints: () => void;
  getAllPolygons: () => void; // New method to fetch polygons
  setIsLoading: (state: (() => boolean) | boolean) => void;
  setMap: (state: (() => L.Map | null) | (L.Map | null)) => void;
}

const initialData: dataType = {
  map: null,
  isLoading: false,
  addPointModal: false,
  points: [],
  polygons: [], // Initialize polygons as an empty array
  showPointList: false,
};

export type storeType = dataType & storeAction;

export const useAppStore = create<storeType>((set) => ({
  ...initialData,

  setAddPointModal: (value) => set(() => ({ addPointModal: value })),
  setShowPointList: (value) => set(() => ({ showPointList: value })),

  // Set the points array
  setPoints: (points) => set(() => ({ points })),

  // Set the polygons array
  setPolygons: (polygons) => set(() => ({ polygons })),

  // Fetch settings (similar to previous implementation)
  getSettings: () => {
    set({ isLoading: true });
    getData("/api/settings", {}).then((res) => {
      set({ settings: res.data, isLoading: false });
    });
  },

  // Fetch all points
  getAllPoints: () => {
    set({ isLoading: true });
    getData("/api/points", {})
      .then((res) => {
        set({ points: res.data, isLoading: false });
      })
      .catch((error) => {
        console.error("Error fetching points:", error);
        set({ isLoading: false });
      });
  },

  // Fetch all polygons
  getAllPolygons: () => {
    set({ isLoading: true });
    getData("/api/polygons", {}).then((res) => {
      set({ polygons: res.data, isLoading: false });
    });
  },

  // Toggle the visibility of a polygon (flag update)
  togglePolygonVisibility: (id: string, currentFlag: number) => {
    set({ isLoading: true });
    postData("/api/polygons/update-flag", {
      id,
      flag: currentFlag === 1 ? 0 : 1,
    }).then(() => {
      // Re-fetch polygons after updating visibility
      getData("/api/polygons", {}).then((res) => {
        set({ polygons: res.data, isLoading: false });
      });
    });
  },

  // Set the loading state
  setIsLoading: (state) => {
    if (typeof state == "boolean") {
      set({ isLoading: state });
    }
    if (typeof state == "function") {
      set({ isLoading: state() });
    }
  },

  // Set the map object
  setMap: (state) => {
    if (typeof state == "function") {
      set({ map: state() });
    } else {
      set({ map: state });
    }
  },
}));

// File: src/css/style.css
.leaflet-container,
.leaflet {
  width: 100%;
  height: 100%;
}

@keyframes spinner {
  0% {
    transform: rotate(0);
  }

  100% {
    transform: rotate(360deg);
  }
}

.spinner-anim {
  animation: spinner 1s infinite;
}

.leaflet-right {
  display: none;
}

// File: src/types/index.ts
// File: src/types/index.ts

export interface IPoint {
  _id: string;
  name: string;
  lat: number;
  lng: number;
  frequency: number;
  status: "active" | "disable";
  date: string;
}

export interface ISettings {
  lat: number;
  lng: number;
  zoom: number;
}

export interface IFormData {
  name: string;
  lat: string;
  lng: string;
  frequency: string;
  lat_settings?: string;
  lng_settings?: string;
  zoom?: string;
  search?: string;
}

// New IPolygon interface for polygons
export interface IPolygon {
  _id: string;
  name: string;
  points: { lat: number; lng: number }[]; // Array of lat/lng for polygon vertices
  flag: number; // 0 (hide) or 1 (show)
  isPolygon: boolean; // True for polygons
  date: string;
}

export interface IModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: IFormData) => void;
  loading: boolean;
  initialData?: IFormData;
}

export interface MapComponentProps {
  points: IPoint[];
  polygons: IPolygon[]; // Add polygons to map component props
  settings: ISettings;
  onMarkerClick: (point: IPoint) => void;
}

// File: src/types/leaflet-offline.d.ts
import "leaflet";

declare module "leaflet" {
  namespace tileLayer {
    function offline(
      urlTemplate: string,
      options?: L.TileLayerOptions,
    ): L.TileLayer;
  }

  namespace control {
    function savetiles(layer: L.TileLayer, options: any): L.Control;
  }
}

interface LeafletOffline {
  getStorageInfo(urlTemplate: string): Promise<any[]>;
  getStoredTilesAsJson(layer: L.TileLayer, data: any[]): Promise<L.GeoJSON>;
}
declare module "leaflet" {
  interface LeafletEvent {
    _tilesforSave?: any[]; // Define the custom property _tilesforSave, change `any[]` to a more specific type if known
  }
}

// File: src/validator/index.ts
import { z } from "zod";

export const pointObject = z.object({
  name: z.string().min(2, {
    message: "Username must be at least 2 characters.",
  }),
  lat: z.number(),
  lng: z.number(),
  frequency: z.number(),
});
export const settingsObject = z.object({
  lat_settings: z.number(),
  lng_settings: z.number(),
  zoom: z.number(),
});

// File: src/components/global/pointAction.tsx
import { Tooltip } from "@nextui-org/react";
import React from "react";
import { Modals } from "../modals";
import { PointForm } from "../forms/pointForm";
import { useModal } from "@/store/useModal";
import { IPoint } from "@/types";
import { DeletePointModal } from "../modals/deletePointModal";
import { EditIcon, Trash2 } from "lucide-react";

export const PointAction = ({ data }: { data: IPoint }) => {
  const setOpen = useModal((state) => state.setOpen);
  return (
    <div className="relative flex items-center gap-4">
      <Tooltip content="edit point">
        <button
          onClick={() =>
            setOpen(
              <Modals title="edit point">
                <PointForm type="edit"></PointForm>
              </Modals>,
              { point: data },
            )
          }
          className="cursor-pointer text-lg text-default-400 active:opacity-50"
        >
          <EditIcon />
        </button>
      </Tooltip>

      <Tooltip color="danger" content="delete point">
        <button
          onClick={() =>
            setOpen(<DeletePointModal data={data}></DeletePointModal>)
          }
          className="cursor-pointer text-lg text-danger active:opacity-50"
        >
          <Trash2 />
        </button>
      </Tooltip>
    </div>
  );
};

// File: src/components/modals/downloadModal.tsx
"use client";
import React, { useEffect } from "react";
import { Modals } from ".";
import { ModalBody, ModalFooter, Spinner } from "@nextui-org/react";
import { useModal } from "@/store/useModal";
export const DownloadModal = ({
  total,
  progress,
}: {
  total: number;
  progress: number;
}) => {
  const setClose = useModal((state) => state.setClose);
  useEffect(() => {
    if (total == progress) {
      setClose();
    }
  }, [total, progress]);
  return (
    <Modals title={"delete point"}>
      <ModalBody>
        <div className="flex w-full items-center justify-between gap-2 text-sm">
          <span>Total Tiles : {total}</span>
          <span>Downloaded Tiles : {progress}</span>

          {/* <div className="h-5 w-full rounded-full bg-gray-200">
            <div
              style={{ width: `${total / progress}%` }}
              className="flex h-full items-center justify-center rounded-full bg-indigo-600 text-xs text-white"
            >
              {progress}%
            </div>
          </div> */}
        </div>
      </ModalBody>
      <ModalFooter>
        <div className="flex w-full justify-center gap-4">
          <Spinner size="sm" label="Please wait..." />
        </div>
      </ModalFooter>
    </Modals>
  );
};

// File: src/components/modals/index.tsx
"use client";
import { Modal, ModalContent, ModalHeader } from "@nextui-org/react";
import { useModal } from "@/store/useModal";
export function Modals({
  children,
  title,
}: {
  children: React.ReactNode;
  title: string;
}) {
  const { isOpen, setClose } = useModal((state) => state);
  return (
    <Modal
      classNames={{ backdrop: "z-[999]", wrapper: "z-[9999]" }}
      isOpen={isOpen}
      onClose={() => setClose()}
    >
      <ModalContent>
        {() => (
          <>
            <ModalHeader className="flex flex-col gap-1">{title}</ModalHeader>
            {children}
          </>
        )}
      </ModalContent>
    </Modal>
  );
}

// File: src/components/modals/deletePointModal.tsx
import React from "react";
import { Modals } from ".";
import { useModal } from "@/store/useModal";
import { deleteData } from "@/services/API";
import { IPoint } from "@/types";
import { Button, ModalBody, ModalFooter } from "@nextui-org/react";
import { useAppStore } from "@/store/store";

export const DeletePointModal = ({ data }: { data: IPoint }) => {
  const setClose = useModal((state) => state.setClose);
  const getAllPoints = useAppStore((state) => state.getAllPoints);
  const setIsLoading = useModal((state) => state.setIsLoading);
  const isLoading = useModal((state) => state.isLoading);
  const deletePointHandler = () => {
    setIsLoading(true);
    deleteData("/api/points", { id: data._id }).then(() => {
      getAllPoints();
      setIsLoading(false);
      setClose();
    });
  };
  return (
    <Modals title={"delete point"}>
      <ModalBody>
        <div className="flex w-full gap-2">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="currentColor"
            className="size-7 text-red-600"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"
            />
          </svg>

          <span>Are you sure you want to delete this point?</span>
        </div>
      </ModalBody>
      <ModalFooter>
        <div className="flex w-full justify-center gap-4">
          <Button
            color="danger"
            variant="light"
            type="button"
            onClick={() => setClose()}
          >
            Close
          </Button>
          <Button
            isLoading={isLoading}
            variant="shadow"
            className="bg-green-600 text-white shadow-green-200"
            onClick={deletePointHandler}
          >
            Add point
          </Button>
        </div>
      </ModalFooter>
    </Modals>
  );
};

// File: src/components/map/Table.tsx
import React, { useState } from "react";
import {
  Chip,
  Spinner,
  Table,
  TableBody,
  TableCell,
  TableColumn,
  TableHeader,
  TableRow,
} from "@nextui-org/react";
import { PointAction } from "../global/pointAction";
import { IPoint } from "@/types";
import { useAppStore } from "@/store/store";
import { postData } from "@/services/API";
const statusColorMap: { [key: string]: "success" | "danger" } = {
  active: "success",
  disable: "danger",
};
const columns = [
  { name: "id", uid: "id" },
  { name: "name", uid: "name" },
  { name: "lat", uid: "lat" },
  { name: "lng", uid: "lng" },
  { name: "frequency", uid: "frequency" },
  { name: "status", uid: "status" },
  { name: "time", uid: "time" },
  { name: "", uid: "action" },
];
export const Tables = () => {
  const { points, isLoading, getAllPoints } = useAppStore((state) => state);
  const [statusLoading, setStatusLoading] = useState(false);
  const changeStatusHandler = (id: string) => {
    setStatusLoading(true);
    postData("/api/points/change-status", { id }).then(() => {
      setStatusLoading(false);
      getAllPoints();
    });
  };

  const renderCell = (point: IPoint, columnKey: string, id: string) => {
    const cellValue = point[columnKey as keyof IPoint];

    switch (columnKey) {
      case "id":
        return <span>{id}</span>;
      case "name":
      case "lat":
      case "lng":
      case "frequency":
        return (
          <div className="flex flex-col">
            <p className="text-sm font-bold text-gray-700">
              {point[columnKey]}
            </p>
          </div>
        );
      case "status":
        return (
          <button onClick={() => changeStatusHandler(point._id)}>
            <Chip
              className="capitalize"
              color={statusColorMap[point.status]}
              size="sm"
              variant="flat"
            >
              {statusLoading ? "wait..." : point.status}
            </Chip>
          </button>
        );
      case "time":
        return (
          <div className="flex flex-col">
            <p className="text-sm font-bold capitalize text-gray-700">
              {new Date(point.date).toLocaleString()}
            </p>
          </div>
        );
      case "action":
        return <PointAction data={point}></PointAction>;
      default:
        return cellValue ? <span>{cellValue}</span> : null;
    }
  };
  return (
    <Table
      classNames={{ wrapper: "bg-transparent shadow-none rounded-none" }}
      className="max-h-fit"
      aria-label="Example table with custom cells"
    >
      <TableHeader columns={columns}>
        {(column) => (
          <TableColumn key={column.uid} align="center">
            {column.name}
          </TableColumn>
        )}
      </TableHeader>
      <TableBody
        loadingContent={<Spinner label="Loading..." />}
        isLoading={isLoading}
        items={points}
        emptyContent="doesn't exist any point  !"
      >
        {(item) => (
          <TableRow key={item._id}>
            {(columnKey) => (
              <TableCell>
                {renderCell(
                  item,
                  columnKey,
                  points.findIndex((p) => p._id === item._id) + 1,
                )}
              </TableCell>
            )}
          </TableRow>
        )}
      </TableBody>
    </Table>
  );
};

// File: src/components/map/toolbar.tsx
import {
  Button,
  DateRangePicker,
  DateValue,
  Input,
  RangeValue,
  Spinner,
  TimeInput,
  TimeInputValue,
} from "@nextui-org/react";
import React, { useState } from "react";
import { Modals } from "../modals";
import { SettingsForm } from "../forms/settingsForm";
import { useForm } from "react-hook-form";
import { useAppStore } from "@/store/store";
import { useModal } from "@/store/useModal";
import { RefreshCw, SearchIcon, Settings, X } from "lucide-react";

export const Toolbar = () => {
  const { points, getAllPoints, isLoading, setPoints } = useAppStore(
    (state) => state,
  );
  const { setOpen } = useModal((state) => state);

  const { register, setValue, watch } = useForm({
    mode: "onBlur",
    defaultValues: {
      search: "",
    },
  });

  const [rotateIcon, setRotateIcon] = useState(false);
  const [date, setDate] = useState<RangeValue<DateValue>>();
  const [from, setFrom] = useState<TimeInputValue>();
  const [to, setTo] = useState<TimeInputValue>();

  const searchVal = watch("search");

  // Search Points Handler
  const searchPointsHandler = () => {
    if (!searchVal) {
      getAllPoints(); // Reset points to default if no search value
      return;
    }

    // Filter points based on search input
    const filteredPoints = points.filter((data) =>
      data.name.toLowerCase().includes(searchVal.toLowerCase()),
    );

    setPoints(filteredPoints);
  };

  // Date and Time Filter Handler
  const sortByDateHandler = () => {
    if (!date?.start || !date?.end) {
      return;
    }

    // Create Date objects for the start and end of the date range
    //@ts-expect-error the
    const startDate = new Date(date.start); //@ts-expect-error the
    const endDate = new Date(date.end);

    // Filter points by date range and time
    const filteredPoints = points.filter((point) => {
      const pointDate = new Date(point.date); // Assuming point.date is a valid string

      // Compare only dates
      const isWithinDateRange = pointDate >= startDate && pointDate <= endDate;

      // If both from and to times are provided, add time comparison
      if (from && to) {
        const pointTime = `${pointDate.getHours()}:${pointDate.getMinutes()}`;
        const fromTime = `${from.hour}:${from.minute}`;
        const toTime = `${to.hour}:${to.minute}`;

        return (
          isWithinDateRange && pointTime >= fromTime && pointTime <= toTime
        );
      }

      // Return true if only date comparison is needed
      return isWithinDateRange;
    });

    // Update the points list with filtered results
    setPoints(filteredPoints);
  };

  return (
    <div className="flex w-full items-center justify-between px-4">
      <div className="flex justify-center gap-16">
        <Input
          isRequired
          className="w-80"
          labelPlacement="outside"
          placeholder="search point..."
          value={searchVal}
          {...register("search")}
          endContent={
            <div className="flex gap-3">
              {searchVal?.length > 0 && (
                <button
                  onClick={() => {
                    setValue("search", "");
                    searchPointsHandler();
                  }}
                >
                  <X />
                </button>
              )}
              <button onClick={searchPointsHandler}>
                <SearchIcon size={20}></SearchIcon>
              </button>
            </div>
          }
          size="md"
        />
      </div>

      <div className="flex flex-row-reverse gap-4">
        <DateRangePicker
          aria-label="filter by date"
          value={date}
          onChange={(x) => setDate(x)}
          hideTimeZone
          defaultValue={date}
        />
        <TimeInput
          label="from"
          value={from}
          onChange={setFrom}
          labelPlacement="outside-left"
        />
        <TimeInput
          label="to"
          value={to}
          onChange={setTo}
          labelPlacement="outside-left"
        />
        <Button
          onClick={sortByDateHandler}
          variant="shadow"
          className="bg-indigo-600 text-white shadow-indigo-200"
        >
          Filter
        </Button>
        {date?.start && (
          <button
            onClick={() => {
              setDate(undefined); // Reset date
              setFrom(undefined);
              setTo(undefined);
              getAllPoints(); // Reset points list
            }}
          >
            <X />
          </button>
        )}
      </div>

      <div className="flex flex-row-reverse items-center gap-4">
        {/* Settings Button */}
        <button
          onClick={() =>
            setOpen(
              <Modals title="edit point">
                <SettingsForm></SettingsForm>
              </Modals>,
            )
          }
          className="flex size-10 items-center justify-center rounded-xl bg-red-600 text-white shadow-lg shadow-red-200 outline-none transition-all duration-300 active:scale-95"
        >
          {isLoading ? <Spinner size="sm" color="white" /> : <Settings />}
        </button>

        <button
          onClick={() => {
            setRotateIcon(true);
            getAllPoints();
          }}
          className="flex size-10 items-center justify-center rounded-xl bg-gray-100 text-gray-600 shadow-lg shadow-gray-200 transition-all duration-300 active:scale-95"
        >
          <RefreshCw />
        </button>
      </div>
    </div>
  );
};

// File: src/components/map/Map.tsx
import React, { useEffect, useState } from "react";
import { MapContainer, Polygon, TileLayer, Tooltip } from "react-leaflet";
import { Spinner } from "@nextui-org/react";
import { useAppStore } from "@/store/store";
import { IPoint } from "@/types";
import { ModalProvider } from "@/providers/ModalProvider";
import { useModal } from "@/store/useModal";
import { Modals } from "../modals";
import { PointForm } from "../forms/pointForm";
import { Tables } from "./Table";
import { Toolbar } from "./toolbar";
import MarkerClusterGroup from "react-leaflet-cluster";
import { DownloadModal } from "../modals/downloadModal";
import { Mark } from "./mark";
import { DrawPolygon } from "@/helper/drawPolygon";
import "leaflet.offline";
import "leaflet/dist/leaflet.css";
import "leaflet-draw";
import L from "leaflet";
import "leaflet-draw/dist/leaflet.draw.css";
import "leaflet/dist/leaflet.css";
import { controlSaveTiles } from "@/helper/controlSaveTiles";
export default function Map() {
  const [progress, setProgress] = useState(0);
  const [total, setTotal] = useState(0);
  const {
    showPointList,
    points,
    getAllPoints,
    getSettings,
    settings,
    isLoading,
    setMap,
    getAllPolygons,
    polygons,
    map,
  } = useAppStore((state) => state);
  const { setOpen, modal } = useModal((state) => state);
  const [pointLabel, setPointLabel] = useState<Partial<IPoint>>({});

  const [once, setOnce] = useState(true);

  // Fetch all points
  useEffect(() => {
    if (once) {
      setOnce(false);
      getAllPoints();
      getSettings();
    }

    if (map) {
      DrawPolygon(map, getAllPolygons);
      map.on("dblclick", (e: L.LeafletMouseEvent) => {
        const { lat, lng } = e.latlng;
        setOpen(
          <Modals title="Create Point">
            <PointForm type="create" />
          </Modals>,
          // @ts-expect-error thee
          { point: { name: "", lat: lat, lng: lng, frequency: 0 } },
        );
      });
      controlSaveTiles({ map, setProgress, setTotal });
    }
  }, [map]);
  useEffect(() => {
    if (progress > 0 && total > 0 && !modal) {
      setOpen(
        <DownloadModal progress={progress} total={total}></DownloadModal>,
      );
    }
  }, [progress, total]);

  return (
    <div className="flex size-full flex-col">
      <ModalProvider></ModalProvider>
      <div className={"relative size-full"}>
        {isLoading ? (
          <div className="flex size-full items-center justify-center bg-gray-50">
            <Spinner label="please wait..." />
          </div>
        ) : (
          <MapContainer
            center={
              settings?.lat
                ? [settings.lat, settings.lng]
                : [35.695246913723636, 51.41011318883557]
            }
            zoom={settings?.zoom ? settings?.zoom : 13}
            scrollWheelZoom={true}
            doubleClickZoom={false}
            ref={setMap}
          >
            <TileLayer
              attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
              url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            />

            <MarkerClusterGroup>
              {points.length > 0 &&
                points.map(
                  (point) =>
                    point.status === "active" && (
                      <Mark
                        key={point._id}
                        point={point}
                        setPointLabel={setPointLabel}
                      ></Mark>
                    ),
                )}
            </MarkerClusterGroup>
            {polygons.length > 0 &&
              polygons.map((polygon) => (
                <Polygon
                  key={polygon._id}
                  positions={polygon.points.map((point) => [
                    point.lat,
                    point.lng,
                  ])}
                >
                  <Tooltip permanent>{polygon.name}</Tooltip>
                </Polygon>
              ))}
          </MapContainer>
        )}
        {pointLabel?.lat && (
          <div
            className={
              "absolute bottom-4 right-4 z-[999] flex flex-col gap-1 rounded-lg bg-white p-2 text-xs transition-all duration-300"
            }
          >
            s<span>lat: {pointLabel?.lat}</span>
            <span>lng: {pointLabel?.lng}</span>
          </div>
        )}
      </div>

      <div
        className={`mt-3 flex w-full flex-col ${
          showPointList ? "h-2/5" : "h-0 overflow-hidden"
        } transition-all duration-300`}
      >
        <Toolbar></Toolbar>
        <Tables></Tables>
      </div>
    </div>
  );
}

// File: src/components/map/PointIcon.tsx
import L from "leaflet";

const PointIcon = new L.Icon({
  iconUrl: "/assets/icon.png",
  iconRetinaUrl: "/assets/icon.png",
  iconAnchor: undefined,
  shadowUrl: undefined,
  shadowSize: undefined,
  shadowAnchor: undefined,
  iconSize: new L.Point(60, 60),
  className: "",
});

export { PointIcon };

// File: src/components/map/mark.tsx
import { EditIcon, Trash2 } from "lucide-react";
import React from "react";
import { Marker, Popup, Tooltip } from "react-leaflet";
import { Modals } from "../modals";
import { DeletePointModal } from "../modals/deletePointModal";
import { PointForm } from "../forms/pointForm";
import { postData } from "@/services/API";
import { IPoint } from "@/types";
import { PointIcon } from "./PointIcon";
import { useAppStore } from "@/store/store";
import { useModal } from "@/store/useModal";

export const Mark = ({
  point,
  setPointLabel,
}: {
  point: IPoint;
  setPointLabel: React.Dispatch<React.SetStateAction<Partial<IPoint>>>;
}) => {
  const { getAllPoints } = useAppStore((state) => state);
  const { setOpen } = useModal((state) => state);
  const changeStatusHandler = (id: string) => {
    postData("/api/points/change-status", { id }).then(() => {
      getAllPoints();
    });
  };
  return (
    <Marker
      key={point._id}
      icon={PointIcon}
      position={[point.lat, point.lng]}
      eventHandlers={{
        mouseover: () => {
          setPointLabel(point);
        },
        mouseout: () => {
          setPointLabel({});
        },
      }}
    >
      <Tooltip direction="bottom" offset={[0, 10]} permanent>
        {point.name}
      </Tooltip>
      <Popup>
        <div className="flex w-full flex-col gap-1">
          <span>name: {point.name}</span>
          <span>lat: {point.lat}</span>
          <span>lng: {point.lng}</span>
          <span>frequency: {point.frequency}</span>
          <span>status: {point.status}</span>

          <div className="mt-2 flex w-full items-center justify-center gap-3">
            <button
              onClick={() =>
                setOpen(
                  <Modals title="edit point">
                    <PointForm type="edit"></PointForm>
                  </Modals>,
                  { point },
                )
              }
              className="cursor-pointer text-lg text-default-400 active:opacity-50"
            >
              <EditIcon />
            </button>

            <button
              onClick={() =>
                setOpen(<DeletePointModal data={point}></DeletePointModal>)
              }
              className="cursor-pointer text-lg text-danger active:opacity-50"
            >
              <Trash2 />
            </button>

            <button
              onClick={() => changeStatusHandler(point._id)}
              className="cursor-pointer text-lg text-warning active:opacity-50"
            >
              <svg
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                strokeWidth="1.5"
                stroke="currentColor"
                className="size-5"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  d="M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
                />
              </svg>
            </button>
          </div>
        </div>
      </Popup>
    </Marker>
  );
};

// File: src/components/sidebar/Sidebar.tsx
import React, { useState } from "react";
import Image from "next/image";
import { useModal } from "@/store/useModal";
import { Modals } from "../modals";
import { PointForm } from "../forms/pointForm";
import { useAppStore } from "@/store/store";

export default function Sidebar() {
  const setOpen = useModal((state) => state.setOpen);
  const [openSidebar, setOpenSidebar] = useState(false);
  const { showPointList, setShowPointList } = useAppStore((state) => state);
  return (
    <div
      className={`${openSidebar ? "min-w-60" : "min-w-16"} relative transition-all duration-300`}
    >
      <div
        className={`${openSidebar ? "min-w-60 p-5" : "min-w-16 p-2"} fixed bottom-0 flex h-full flex-col items-center gap-4 bg-indigo-100 pt-3 transition-all  duration-300`}
      >
        <button
          onClick={() => setOpenSidebar(!openSidebar)}
          className="flex size-10 items-center justify-center rounded-xl bg-indigo-200 text-indigo-600"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="currentColor"
            className="size-6"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5"
            />
          </svg>
        </button>

        <div className="my-10 flex h-auto w-full items-center justify-center">
          <Image
            src="/assets/logo.png"
            width={0}
            height={0}
            sizes="100vw"
            className={`${openSidebar ? "w-20" : "w-10"} object-cover`}
            alt=""
            priority
          />
        </div>

        <button
          onClick={() =>
            setOpen(
              <Modals title="add new point">
                <PointForm></PointForm>
              </Modals>,
            )
          }
          className={`${openSidebar ? "h-14 w-full px-4" : "size-10  justify-center"} flex items-center gap-2 overflow-hidden rounded-xl bg-indigo-200 font-bold text-indigo-600 transition-all duration-300`}
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="currentColor"
            className={`${openSidebar ? "size-6" : "size-5"}`}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
            />
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z"
            />
          </svg>

          {openSidebar && <span>Add new point</span>}
        </button>

        <button
          onClick={() => setShowPointList(!showPointList)}
          className={`${openSidebar ? "h-14 w-full px-4" : "size-10  justify-center"} flex items-center gap-2 overflow-hidden rounded-xl bg-indigo-200 font-bold text-indigo-600 transition-all duration-300`}
        >
          {showPointList ? (
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth="1.5"
              stroke="currentColor"
              className={`${openSidebar ? "size-6" : "size-5"}`}
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
              />
            </svg>
          ) : (
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth="1.5"
              stroke="currentColor"
              className={`${openSidebar ? "size-6" : "size-5"}`}
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M2.036 12.322a1.012 1.012 0 0 1 0-.639C3.423 7.51 7.36 4.5 12 4.5c4.638 0 8.573 3.007 9.963 7.178.07.207.07.431 0 .639C20.577 16.49 16.64 19.5 12 19.5c-4.638 0-8.573-3.007-9.963-7.178Z"
              />
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
              />
            </svg>
          )}

          {openSidebar && (
            <span>
              {showPointList ? "Hide points list" : "Show points list"}
            </span>
          )}
        </button>
      </div>
    </div>
  );
}

// File: src/components/forms/settingsForm.tsx
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { settingsObject } from "@/validator";
import { Button, Input, ModalBody, ModalFooter } from "@nextui-org/react";
import { useModal } from "@/store/useModal";
import { postData } from "@/services/API";
export const SettingsForm = () => {
  const { setIsLoading, isLoading, setClose } = useModal((state) => state);
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<z.infer<typeof settingsObject>>({
    resolver: zodResolver(settingsObject),

    defaultValues: {
      lat_settings: 0,
      lng_settings: 0,
      zoom: 11,
    },
  });

  const submitHandler = (data: z.infer<typeof settingsObject>) => {
    setIsLoading(true);
    postData("/api/settings", {
      lat: data.lat_settings,
      lng: data.lng_settings,
      zoom: data.zoom,
    })
      .then(() => {
        setIsLoading(false);
        window.location.reload();
      })
      .catch(() => {
        setIsLoading(false);
      });
  };
  return (
    <form
      className="flex w-full flex-col gap-4"
      onSubmit={handleSubmit((x) => submitHandler(x))}
    >
      <ModalBody>
        <div className="flex w-full flex-col gap-4">
          <Input
            isRequired
            label="Lat"
            labelPlacement="outside"
            placeholder="Enter point lat"
            isInvalid={!!errors.lat_settings}
            errorMessage="lat is required"
            {...register("lat_settings", { required: true })}
          />

          <Input
            isRequired
            label="Lng"
            labelPlacement="outside"
            placeholder="Enter point lng"
            isInvalid={!!errors.lng_settings}
            errorMessage="lng is required"
            {...register("lng_settings", { required: true })}
          />

          <Input
            isRequired
            label="Zoom"
            labelPlacement="outside"
            placeholder="Enter map zoom"
            isInvalid={!!errors.zoom}
            errorMessage="zoom is required"
            {...register("zoom", { required: true })}
          />
        </div>
      </ModalBody>
      <ModalFooter>
        <div className="flex w-full justify-center gap-4">
          <Button color="danger" variant="light" onClick={() => setClose()}>
            Close
          </Button>
          <Button
            isLoading={isLoading}
            variant="shadow"
            className="bg-green-600 text-white shadow-green-200"
            onClick={handleSubmit(submitHandler)}
          >
            Save
          </Button>
        </div>
      </ModalFooter>
    </form>
  );
};

// File: src/components/forms/pointForm.tsx
import { postData } from "@/services/API";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { pointObject } from "@/validator";
import { Button, Input, ModalBody, ModalFooter } from "@nextui-org/react";
import { useModal } from "@/store/useModal";
import { useAppStore } from "@/store/store";
export const PointForm = ({ type }: { type?: "edit" | "create" }) => {
  const { data, setIsLoading, isLoading, setClose } = useModal(
    (state) => state,
  );
  const getAllPoints = useAppStore((state) => state.getAllPoints);
  const {
    register,
    handleSubmit,
    reset,
    formState: { errors },
  } = useForm<z.infer<typeof pointObject>>({
    resolver: zodResolver(pointObject),

    defaultValues: {
      name: data.point?.name || "",
      lat: data.point?.lat || 0,
      lng: data.point?.lng || 0,
      frequency: data.point?.frequency || 0,
    },
  });

  const submitHandler = (newPoint: z.infer<typeof pointObject>) => {
    if (type == "edit") {
      setIsLoading(true);
      postData("/api/points/update-point", {
        ...newPoint,
        id: data.point?._id,
      }).then(() => {
        setIsLoading(false);
        getAllPoints();
        reset({ name: "", lat: 0, lng: 0, frequency: 0 });
        setClose();
      });
    } else {
      setIsLoading(true);
      postData("/api/points", { ...newPoint }).then(() => {
        getAllPoints();
        setIsLoading(false);

        reset({ name: "", lat: 0, lng: 0, frequency: 0 });
        setClose();
      });
    }
  };
  return (
    <>
      <form
        className="flex w-full flex-col gap-4"
        onSubmit={handleSubmit((x) => submitHandler(x))}
      >
        <ModalBody>
          <Input
            isRequired
            label="Name"
            labelPlacement="outside"
            placeholder="Enter point name"
            isInvalid={!!errors.name}
            errorMessage="name is required"
            {...register("name", { required: true })}
          />

          <Input
            isRequired
            label="Lat"
            labelPlacement="outside"
            placeholder="Enter point lat"
            isInvalid={!!errors.lat}
            errorMessage="lat is required"
            {...register("lat", { required: true })}
          />

          <Input
            isRequired
            label="Lng"
            labelPlacement="outside"
            placeholder="Enter point lng"
            isInvalid={!!errors.lng}
            errorMessage="lng is required"
            {...register("lng", { required: true })}
          />

          <Input
            isRequired
            label="Frequency"
            labelPlacement="outside"
            placeholder="Enter point frequency"
            isInvalid={!!errors.frequency}
            errorMessage="frequency is required"
            {...register("frequency", { required: true })}
          />
        </ModalBody>
        <ModalFooter>
          <div className="flex w-full justify-center gap-4">
            <Button
              color="danger"
              variant="light"
              type="button"
              onClick={() => setClose()}
            >
              Close
            </Button>
            <Button
              isLoading={isLoading}
              variant="shadow"
              className="bg-green-600 text-white shadow-green-200"
              type="submit"
            >
              Add point
            </Button>
          </div>
        </ModalFooter>
      </form>
    </>
  );
};

// File: src/providers/ModalProvider.tsx
"use client";
import React from "react";
import { useModal } from "@/store/useModal";

export const ModalProvider = () => {
  const Model = useModal((state) => state.modal);
  return <>{Model}</>;
};

// File: models/PolygonModel.ts
import mongoose from "mongoose";

const polygonSchema = new mongoose.Schema({
  name: { type: String, required: true },
  points: [{ lat: Number, lng: Number }], // Array of polygon vertices
  flag: { type: Number, default: 1 }, // 0 (hide) or 1 (show)
  isPolygon: { type: Boolean, default: true }, // True for polygons
  date: { type: Date, default: Date.now },
  deletedAt: { type: mongoose.Schema.Types.Mixed, default: null },
});
const PolygonsModel =
  mongoose.models.Polygons || mongoose.model("Polygons", polygonSchema);

export default PolygonsModel;

// File: models/SettingsModel.ts
import mongoose from "mongoose";

const schema = new mongoose.Schema({
  lat: { type: Number, required: true, default: 35.694523130867424 },
  lng: { type: Number, required: true, default: 51.30922197948697 },
  zoom: { type: Number, required: true, default: 13 },
});

const SettingsModel =
  mongoose.models.SettingsModel || mongoose.model("SettingsModel", schema);

export default SettingsModel;

// File: models/pointsModel.ts
import mongoose from "mongoose";

const schema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  lat: {
    type: Number,
    required: true,
  },
  lng: {
    type: Number,
    required: true,
  },
  frequency: {
    type: Number,
    required: true,
  },
  status: {
    type: String,
    default: "active",
  },
  date: {
    type: Date,
    default: () => Date.now(),
  },
  deletedAt: {
    type: mongoose.Schema.Types.Mixed,
    default: null,
  },
});

const PointsModel = mongoose.models.Points || mongoose.model("Points", schema);

export default PointsModel;

// File: configs/db.ts
import mongoose from "mongoose";

const connectDB = async () => {
  try {
    if (mongoose.connections[0].readyState) {
      return;
    } else {
      await mongoose.connect(process.env.MONGO_URL!);
      console.log("Connected to MongoDB");
    }
  } catch (error) {
    console.error("Failed to connect to MongoDB:", error);
  }
};

export default connectDB;

