// File: src/app/providers.tsx
"use client";
import { NextUIProvider } from "@nextui-org/react";

export function Providers({ children }: { children: React.ReactNode }) {
  return <NextUIProvider>{children}</NextUIProvider>;
}

// File: src/app/layout.tsx
import { Providers } from "./providers";
import { connectDB } from "@/configs/db";

import "leaflet/dist/leaflet.css";
import "leaflet-draw/dist/leaflet.draw.css";
import "leaflet/dist/leaflet.css";
import "./globals.css";
import "../css/style.css";
export const metadata = {
  title: "Map",
  description: "Map Selector by shahyad karimi",
};

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  await connectDB();
  return (
    <html lang="en">
      <body>
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}

// File: src/app/api/polygons/update-flag/route.ts
import { connectDB } from "@/configs/db";
import PolygonsModel from "@/models/PolygonModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id, flag } = body;

    // Update polygon flag based on provided id and flag
    await PolygonsModel.findOneAndUpdate({ _id: id }, { $set: { flag } });

    return NextResponse.json({ message: "Flag updated!" });
  } catch (err) {
    // @ts-expect-error the
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}

// File: src/app/api/polygons/route.ts
import { connectDB } from "@/configs/db";
import PolygonsModel from "@/models/PolygonModel";
import { NextResponse } from "next/server";

// Create a new polygon
export async function POST(req: Request) {
  try {
    await connectDB(); // Ensure DB connection is successful
    const body = await req.json();
    const { name, points, flag } = body;

    if (!name || !points || flag === undefined) {
      throw new Error("Missing required fields");
    }

    const polygon = await PolygonsModel.create({
      name,
      points,
      flag,
      isPolygon: true,
    });

    return NextResponse.json({
      message: "Polygon created successfully!",
      polygon,
    });
  } catch (err) {
    // @ts-expect-error the
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}

// Get polygons (without deleted ones)
export async function GET() {
  try {
    await connectDB();
    const polygons = await PolygonsModel.find({
      isPolygon: true,
      deletedAt: null,
      flag: 1,
    });
    return NextResponse.json(polygons);
  } catch (err) {
    // @ts-expect-error the
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}

// Update polygon
export async function PUT(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id, name, points, flag, deletedAt } = body;

    await PolygonsModel.findOneAndUpdate(
      { _id: id },
      { $set: { name, points, flag, deletedAt } },
    );

    return NextResponse.json({ message: "Polygon updated!" });
  } catch (err) {
    // @ts-expect-error the
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}

// Soft delete polygon by setting `deletedAt`
export async function DELETE(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id } = body;

    await PolygonsModel.findOneAndUpdate(
      { _id: id },
      { $set: { deletedAt: new Date() } },
    );

    return NextResponse.json({ message: "Polygon deleted successfully!" });
  } catch (err) {
    // @ts-expect-error the
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}

// File: src/app/api/settings/route.ts
import { connectDB } from "@/configs/db";
import SettingsModel from "@/models/SettingsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { lat, lng, zoom, PointIcon } = body;
    await SettingsModel.findOneAndUpdate(
      { _id: "6703d33db86aa836f46946c6" },
      { $set: { lat, lng, zoom, PointIcon } },
    );
    return NextResponse.json(
      { message: "Point updated successfully!" },
      { status: 200 },
    );
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

export async function GET() {
  try {
    await connectDB();
    const settings = await SettingsModel.findOne(
      { _id: "6703d33db86aa836f46946c6" },
      "-__v",
    );
    if (settings) {
      await SettingsModel.create({
        _id: "6703d33db86aa836f46946c6",
      });
    }
    return NextResponse.json(settings);
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/uploads/svg/route.ts
import { NextResponse } from "next/server";
import path from "path";
import { mkdir, writeFile } from "fs/promises";

export const POST = async (req: any) => {
  try {
    const formData = await req.formData();
    const files = formData.getAll("file");

    if (!files || files.length === 0) {
      return NextResponse.json({ error: "No file received." }, { status: 400 });
    }

    const file = files[0]; // Use the first file in the list
    const filename = file.name.replace(/\s/g, "_");
    const uploadDir = path.join(process.cwd(), "public/assets");

    // Ensure the upload directory exists
    await mkdir(uploadDir, { recursive: true });

    // Convert the file to a buffer using arrayBuffer and Buffer.from
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);

    // Write the file to the upload directory
    await writeFile(path.join(uploadDir, filename), buffer);

    return NextResponse.json(
      {
        name: filename.replace(".svg", ""),
        url: path.join("/assets", filename),
      },
      { status: 201 },
    );
  } catch (error) {
    console.error("Error occurred:", error);
    return NextResponse.json(
      { message: "File upload failed." },
      { status: 500 },
    );
  }
};

// File: src/app/api/points/del/route.ts
import { connectDB } from "@/configs/db";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function DELETE(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id } = body;

    await PointsModel.findByIdAndDelete({ _id: id });
    return NextResponse.json({ message: "Point deleted successfully!" });
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/points/route.ts
import { connectDB } from "@/configs/db";
import { startPointWorker } from "@/helper/workerManager";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const {
      lat,
      lng,
      date,
      deletedAt,
      name,
      frequency,
      iconType,
      active,
      port,
      requireData,
      connect,
      status,
      level,
    } = body;

    console.log("fuk");
    const points = await PointsModel.create({
      lat,
      lng,
      date,
      name,
      iconType,
      frequency,
      deletedAt,
      active,
      port,
      requireData,
      connect,
      status,
      level,
    });
    return NextResponse.json(
      { message: "Point created successfully!", points },
      { status: 200 },
    );
  } catch (err) {
    console.log(err);
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

export async function GET() {
  try {
    await connectDB();
    const points = await PointsModel.find({ deletedAt: null }, "-__v");
    return NextResponse.json(points);
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}
export async function PUT(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const {
      lat,
      lng,
      id,
      name,
      point,
      frequency,
      iconType,
      active,
      port,
      requireData,
      connect,
      status,
      level,
    } = body;

    await PointsModel.findOneAndUpdate(
      { _id: id },
      {
        $set: {
          lat,
          lng,
          name,
          point,
          frequency,
          iconType,
          active,
          port,
          requireData,
          connect,
          status,
          level,
        },
      },
    );

    return NextResponse.json({ message: "Polygon updated!" });
  } catch (err) {
    // @ts-expect-error the
    return NextResponse.json({ message: err.message }, { status: 500 });
  }
}
export async function DELETE(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id } = body;

    await PointsModel.findOneAndUpdate(
      { _id: id },
      { $set: { deletedAt: new Date() } },
    );
    return NextResponse.json({ message: "Point deleted successfully!" });
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/points/search/route.ts
import { connectDB } from "@/configs/db";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { search } = body;

    const points = await PointsModel.find({ name: search, deletedAt: null });
    return NextResponse.json(points);
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/points/change-status/route.ts
import { connectDB } from "@/configs/db";
import PointsModel from "@/models/pointsModel";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id } = body;

    const point = await PointsModel.findOne({ _id: id });
    await PointsModel.findOneAndUpdate(
      { _id: id },
      { $set: { status: !point?.status } },
    );

    return NextResponse.json({ message: "Point status updated!" });
  } catch (err) {
    return NextResponse.json({ message: err }, { status: 500 });
  }
}

// File: src/app/api/lines/route.ts
import { NextResponse } from "next/server";
import LineModel from "@/models/LineModel";
import { connectDB } from "@/configs/db";
import { handleError } from "@/utils/errorHandler";

export async function POST(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { startPoint, endPoint, length, angle } = body;

    if (
      !startPoint ||
      !endPoint ||
      length === undefined ||
      angle === undefined
    ) {
      return NextResponse.json(
        { message: "Missing required fields" },
        { status: 400 },
      );
    }

    const line = await LineModel.create({
      startPoint,
      endPoint,
      length,
      angle,
    });

    return NextResponse.json({ message: "Line created successfully!", line });
  } catch (err: any) {
    return NextResponse.json({ message: "somthing went wrong" });
  }
}
export async function GET() {
  try {
    await connectDB();
    const lines = await LineModel.find({ deletedAt: null }); // Fetch all non-deleted lines
    return NextResponse.json(lines);
  } catch (err: any) {
    return handleError(err);
  }
}
export async function DELETE(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id } = body;

    if (!id) {
      return NextResponse.json(
        { message: "Line ID is required" },
        { status: 400 },
      );
    }

    const deletedLine = await LineModel.findOneAndUpdate(
      { _id: id, deletedAt: null }, // Ensure that the line hasn't been soft-deleted already
      { $set: { deletedAt: new Date() } },
      { new: true },
    );

    if (!deletedLine) {
      return NextResponse.json({ message: "Line not found" }, { status: 404 });
    }

    return NextResponse.json({
      message: "Line deleted successfully!",
      deletedLine,
    });
  } catch (err: any) {
    return handleError(err);
  }
}
export async function PUT(req: Request) {
  try {
    await connectDB();
    const body = await req.json();
    const { id, startPoint, endPoint, length, angle, deletedAt } = body;

    if (!id) {
      return NextResponse.json(
        { message: "Line ID is required" },
        { status: 400 },
      );
    }

    const updatedLine = await LineModel.findOneAndUpdate(
      { _id: id, deletedAt: null }, // Ensure that the line exists and hasn't been soft-deleted
      { $set: { startPoint, endPoint, length, angle, deletedAt } },
      { new: true }, // Return the updated document
    );

    if (!updatedLine) {
      return NextResponse.json({ message: "Line not found" }, { status: 404 });
    }

    return NextResponse.json({
      message: "Line updated successfully!",
      updatedLine,
    });
  } catch (err: any) {
    return handleError(err);
  }
}

// File: src/app/page.tsx
import dynamic from "next/dynamic";

const Map = dynamic(() => import("@/components/map/Map"), {
  ssr: false,
});
const Sidebar = dynamic(() => import("@/components/sidebar/Sidebar"), {
  ssr: false,
});

export default function Home() {
  return (
    <div className="flex h-dvh w-full items-center">
      <Sidebar />
      <Map />
    </div>
  );
}

// File: src/app/globals.css
@tailwind base;
@tailwind components;
@tailwind utilities;

::-webkit-scrollbar {
  width: 0;
  height: 0;
}

// File: src/helper/math.ts
export const calculateDistance = (
  point1: L.LatLng,
  point2: L.LatLng,
): number => {
  const R = 6371e3; // Radius of the Earth in meters
  const φ1 = (point1.lat * Math.PI) / 180;
  const φ2 = (point2.lat * Math.PI) / 180;
  const Δφ = ((point2.lat - point1.lat) * Math.PI) / 180;
  const Δλ = ((point2.lng - point1.lng) * Math.PI) / 180;

  const a =
    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  const distance = R * c; // Distance in meters
  return distance;
};

// Function to calculate angle in degrees between two points
export const calculateAngle = (point1: L.LatLng, point2: L.LatLng): number => {
  const Δλ = point2.lng - point1.lng;
  const Δφ = point2.lat - point1.lat;
  const angle = (Math.atan2(Δφ, Δλ) * 180) / Math.PI; // Angle in degrees
  return angle;
};

// File: src/helper/clientWorker.js
"use server";
import { parentPort, workerData } from "worker_threads";
import { io } from "socket.io-client";

const { url, clientId, data } = workerData;

const socket = io(url);
socket.on("connect", () => {
  console.log(`Connected to server at ${url}`);
  socket.emit("initial_data", { clientId, data });
});

socket.on("data_packet", (data) => {
  console.log(`Received data from ${url}:`, data);
  parentPort?.postMessage({ status: "data", data });
});

socket.on("error", (err) => {
  console.error(`Socket error on ${url}:`, err);
  parentPort?.postMessage({ status: "error", error: err });
});

// File: src/helper/draw.ts
/* eslint-disable no-console */
import { deleteData, postData, putData } from "@/services/API";
import L, { LatLng } from "leaflet";
import { calculateAngle, calculateDistance } from "./math";
import { useAppStore } from "@/store/store";

// Draw function to handle both lines and polygons
export const Draw = async (map: L.Map) => {
  const drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);
  useAppStore.getState().setDrawnItems(drawnItems);

  // Load existing polygons from the database
  const drawAllPolygon = async () =>
    await useAppStore.getState().getAllPolygons();
  const drawAllLine = async () => await useAppStore.getState().getAllLines();
  const drawLayers = async () => {
    const [Polygons, AllLines] = await Promise.all([
      drawAllPolygon(),
      drawAllLine(),
    ]);
    drawnItems.clearLayers();
    Polygons.map((polygon) => {
      const layer = L.polygon(
        polygon.points.map((point) => [point.lat, point.lng]),
        { interactive: true },
      );
      //@ts-expect-error the
      layer.options.id = polygon._id; // Store the polygon's DB ID in the layer options

      // drawnItems.removeLayer(polygon._id);
      drawnItems.addLayer(layer);
    });
    AllLines.forEach((line) => {
      const latlngs = [
        [line.startPoint.lat, line.startPoint.lng],
        [line.endPoint.lat, line.endPoint.lng],
      ];
      //@ts-expect-error the
      const layer = L.polyline(latlngs, { interactive: true });

      //@ts-expect-error the
      layer.options.id = line._id; // Store the line's DB ID in the layer options
      drawnItems.addLayer(layer);

      // Calculate distance and angle
      //@ts-expect-error the
      const distance = calculateDistance(line.startPoint, line.endPoint);
      //@ts-expect-error the
      const angle = calculateAngle(line.startPoint, line.endPoint);

      const popupContent = `
    <strong>Line Info</strong><br>
    Length: ${(distance / 1000).toFixed(2)} km<br>
    Angle: ${angle.toFixed(2)}°
  `;
      layer.bindPopup(popupContent).openPopup();
    });
    useAppStore.getState().setDrawnItems(drawnItems);
  };
  drawLayers();

  // Create draw control for both polygons and lines
  const drawControl = new L.Control.Draw({
    position: "topright",
    draw: {
      polygon: {
        allowIntersection: false,
        showArea: true,
        shapeOptions: { color: "#bada55" },
      },
      polyline: {
        allowIntersection: false,
      },
      marker: false,
      rectangle: false,
      circle: false,
      circlemarker: false,
    },
    edit: {
      featureGroup: drawnItems, // Allow editing and removing of drawn shapes
      edit: {
        selectedPathOptions: {
          color: "#666666",
        },
      },
      remove: true,
    },
  });
  map.addControl(drawControl);

  // Handle shape creation (either polygon or line)
  //@ts-expect-error the
  map.on(L.Draw.Event.CREATED, function (event: L.DrawEvents.Created) {
    const layer = event.layer;
    drawnItems.addLayer(layer);
    if (event.layerType === "polygon") {
      const latlngs = (layer as L.Polygon).getLatLngs() as L.LatLng[][];
      const flattenedLatLngs = Array.isArray(latlngs[0]) ? latlngs[0] : latlngs;
      const latlngsMapped = flattenedLatLngs.map((latlng) => ({
        lat: (latlng as LatLng).lat,
        lng: (latlng as LatLng).lng,
      }));
      const name = prompt("Enter a name for the polygon:");
      if (!name) {
        alert("Polygon name is required!");
        return;
      }
      postData("/api/polygons", { name, points: latlngsMapped, flag: 1 })
        .then((response) => {
          const newPolygon = response.data.polygon;
          useAppStore.getState().pushToHistory({
            actionType: "create",
            type: "polygon",
            polygon: newPolygon,
          });
          //@ts-expect-error the
          layer.options.id = newPolygon._id; // Assign the polygon ID from the response
          drawnItems.removeLayer(layer);
          drawLayers();
        })
        .catch((err) => {
          console.error("Error creating polygon:", err);
          alert("Failed to create the polygon. Please try again.");
        });
    } else if (event.layerType === "polyline") {
      const latlngs = (layer as L.Polyline).getLatLngs() as L.LatLng[];
      if (latlngs.length >= 2) {
        const point1 = latlngs[0];
        const point2 = latlngs[1];
        const distance = calculateDistance(point1, point2);
        const angle = calculateAngle(point1, point2);
        postData("/api/lines", {
          startPoint: { lat: point1.lat, lng: point1.lng },
          endPoint: { lat: point2.lat, lng: point2.lng },
          length: distance,
          angle,
        })
          .then((response) => {
            console.log("create");
            useAppStore.getState().pushToHistory({
              actionType: "create",
              type: "polyline",
              line: response.data.line,
            });
            //@ts-expect-error the
            layer.options.id = response.data.line._id; // Assign the line ID from the response
            drawnItems.removeLayer(layer);
            drawLayers();
          })
          .catch((err) => {
            console.error("Error saving line:", err);
          });

        const popupContent = `
          <strong>Line Info</strong><br>
          Length: ${(distance / 1000).toFixed(2)} km<br>
          Angle: ${angle.toFixed(2)}°
        `;
        layer.bindPopup(popupContent).openPopup();
      }
    }
  });

  // Handle shape editing (both lines and polygons)
  //@ts-expect-error the
  map.on(L.Draw.Event.EDITED, function (event: L.DrawEvents.Edited) {
    const layers = event.layers;
    layers.eachLayer(function (layer: any) {
      const id = layer.options.id;
      if (!id) {
        console.error("No ID found for the shape.");
        return;
      }

      if (layer instanceof L.Polygon) {
        const updatedLatLngs = layer
          .getLatLngs()[0]
          //@ts-expect-error the
          .map((latlng: L.LatLng) => ({
            lat: latlng.lat,
            lng: latlng.lng,
          }));
        putData("/api/polygons", { id, points: updatedLatLngs })
          .then(() => {
            drawnItems.removeLayer(layer);
            drawLayers();
          })
          .catch((err) => {
            console.error("Error updating polygon:", err);
            alert("Failed to update the polygon. Please try again.");
          });
      } else if (layer instanceof L.Polyline) {
        const latlngs = layer.getLatLngs() as L.LatLng[];
        if (latlngs.length >= 2) {
          const point1 = latlngs[0];
          const point2 = latlngs[1];
          const distance = calculateDistance(point1, point2);
          const angle = calculateAngle(point1, point2);
          putData("/api/lines", {
            id,
            startPoint: { lat: point1.lat, lng: point1.lng },
            endPoint: { lat: point2.lat, lng: point2.lng },
            length: distance,
            angle,
          })
            .then(() => {
              drawnItems.removeLayer(layer);
              drawLayers();
            })
            .catch((err) => {
              console.error("Error updating line:", err);
            });
        }
      }
    });
  });

  // Handle shape deletion (both lines and polygons)
  //@ts-expect-error the
  map.on(L.Draw.Event.DELETED, function (event: L.DrawEvents.Deleted) {
    const layers = event.layers;
    layers.eachLayer(function (layer: any) {
      const id = layer.options.id;
      if (!id) {
        console.error("No ID found for the shape.");
        return;
      }

      if (layer instanceof L.Polygon) {
        deleteData("/api/polygons", { id })
          .then(() => {
            drawLayers();
          })
          .catch((err) => {
            console.error("Error deleting polygon:", err);
            alert("Failed to delete the polygon. Please try again.");
          });
      } else if (layer instanceof L.Polyline) {
        deleteData("/api/lines", { id })
          .then(() => {
            drawLayers();
          })
          .catch((err) => {
            console.error("Error deleting line:", err);
          });
      }
    });
  });
};

// File: src/helper/controlSaveTiles.ts
import "leaflet.offline";
import "leaflet-draw";
import L from "leaflet";
export const controlSaveTiles = ({
  map,
  setProgress,
  setTotal,
}: {
  map: L.Map;
  setProgress: React.Dispatch<React.SetStateAction<number>>;
  setTotal: React.Dispatch<React.SetStateAction<number>>;
}) => {
  const tileLayerOffline = L.tileLayer.offline(
    "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    {
      attribution:
        '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
      subdomains: "abc",
      minZoom: 11,
      maxZoom: 16,
    },
  );
  if (tileLayerOffline.addTo) {
    tileLayerOffline.addTo(map);
  }
  const controlSaveTiles = L.control.savetiles(tileLayerOffline, {
    position: "topright",
    zoomlevels: [11, 12, 13, 14, 15, 16],
    confirm(layer: any, succescallback: () => void) {
      if (
        window.confirm(
          `Are you sure you want to download ${layer._tilesforSave.length} tiles?`,
        )
      ) {
        succescallback();
      }
    },
    confirmRemoval(layer: any, successCallback: () => void) {
      if (window.confirm("Are you sure you want to remove all tiles?")) {
        successCallback();
      }
    },
    saveText: `<div class="w-full h-full flex justify-center items-center">
  <svg
      xmlns="http://www.w3.org/2000/svg"
      fill="none"
      viewBox="0 0 24 24"
      stroke-width="1.5"
      stroke="currentColor"
      class="size-5"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3"
      />
    </svg>
  </div>`,
    rmText: `<div class="w-full h-full flex justify-center items-center">
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="1.5"
        stroke="currentColor"
        class="size-5"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"
        />
      </svg>
    </div>`,
  });
  if (controlSaveTiles.addTo) {
    controlSaveTiles.addTo(map);
  }

  let progress: number;
  tileLayerOffline.on("savestart", (e: any) => {
    progress = 0;
    setTotal(e._tilesforSave.length);
  });
  tileLayerOffline.on("savetileend", () => {
    progress += 1;
    setProgress(progress);
  });
};

// File: src/helper/workerManager.ts
/* eslint-disable no-console */
"use server";
import { Worker } from "worker_threads";
import PointsModel from "@/models/pointsModel";
import { connectDB } from "@/configs/db";
import PointsDataModel from "@/models/pointDataModel";

// Map to keep track of running workers
const workersMap = new Map();

// Function to start a worker for a given point
const startPointWorker = async (
  pointId: string,
  port: number,
  data: string[] = [],
) => {
  // Check if the worker for the point is already running
  if (workersMap.has(pointId)) {
    console.log(`Worker for point ${pointId} is already running.`);
    return; // Exit the function if the worker is already running
  }

  connectDB();
  const point = await PointsModel.findById(pointId);
  if (!point) {
    throw new Error("Point not found");
  }

  const url = `http://localhost:${port || 5000}`;
  const clientId = Math.random().toString(36).substr(2, 9);

  const worker = new Worker("./src/helper/clientWorker.js", {
    workerData: { url, clientId, data: data },
  });

  workersMap.set(pointId, worker); // Store worker in the map

  worker.on("message", async (msg) => {
    if (msg.status === "data") {
      console.log(`Received data from worker for ${point.name}:`, msg.data);
      const data = await PointsDataModel.create({
        data: msg.data,
      });
      await PointsModel.findByIdAndUpdate(pointId, {
        $set: { workerStatus: "active", PointsData: data },
      });
    } else if (msg.status === "error") {
      console.error(`Worker error for ${point.name}`);
      await PointsModel.findByIdAndUpdate(pointId, {
        $set: { workerStatus: "error" },
      });
    }
  });

  worker.on("exit", async (code) => {
    workersMap.delete(pointId); // Remove the worker from the map
    if (code !== 0) {
      console.error(`Worker for ${point.name} exited with code ${code}`);
      await PointsModel.findByIdAndUpdate(pointId, {
        $set: { workerStatus: "error" },
      });
    } else {
      await PointsModel.findByIdAndUpdate(pointId, {
        $set: { workerStatus: "inactive" },
      });
    }
  });
};

// Function to shut down a worker for a given point
const shutdownWorker = async (pointId: string) => {
  const worker = workersMap.get(pointId);
  if (!worker) {
    throw new Error("Worker not found for this point");
  }

  worker.terminate(); // Gracefully terminate the worker
  workersMap.delete(pointId); // Remove the worker from the map

  await PointsModel.findByIdAndUpdate(pointId, {
    $set: { workerStatus: "inactive" },
  });

  console.log(`Worker for point ${pointId} has been shut down`);
};

export { startPointWorker, shutdownWorker };

// File: src/helper/helper.ts
export const dateFormatter = (
  date: {
    start: { day: number; month: number; year: number };
    end: { day: number; month: number; year: number };
  },
  time: { hour: number; minute: number },
) => {
  return {
    start: `${date.start.month}/${date.start.day}/${date.start.year} ${time.hour}:${time.minute}`,
    end: `${date.end.month}/${date.end.day}/${date.end.year} ${time.hour}:${time.minute}`,
  };
};

// File: src/helper/geometry.ts
// src/helper/geometry.ts

import { LatLng } from "leaflet";

// Haversine formula to calculate the distance between two LatLng points
export function getDistance(point1: LatLng, point2: LatLng): number {
  const R = 6371e3; // Radius of the earth in meters
  const φ1 = (point1.lat * Math.PI) / 180;
  const φ2 = (point2.lat * Math.PI) / 180;
  const Δφ = ((point2.lat - point1.lat) * Math.PI) / 180;
  const Δλ = ((point2.lng - point1.lng) * Math.PI) / 180;

  const a =
    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  const distance = R * c; // Distance in meters
  return distance;
}

// File: src/helper/offline.ts
/* global L, LeafletOffline, $ */

const urlTemplate = "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png";

// Show tile list function
function showTileList(): void {
  // @ts-expect-error the
  LeafletOffline.getStorageInfo(urlTemplate).then((r: any[]) => {
    const list = document.getElementById("tileinforows");
    if (list) {
      list.innerHTML = "";
      r.forEach((tile: any, i: number) => {
        const createdAt = new Date(tile.createdAt);
        list.insertAdjacentHTML(
          "beforeend",
          `<tr><td>${i}</td><td>${tile.url}</td><td>${tile.key}</td><td>${createdAt.toDateString()}</td></tr>`,
        );
      });
    }
  });
}

// @ts-expect-error the
$("#storageModal").on("show.bs.modal", showTileList);

// Initialize map and base layer
const map = L.map("map");
const baseLayer = L.tileLayer
  .offline(urlTemplate, {
    attribution: "Map data {attribution.OpenStreetMap}",
    subdomains: "abc",
    minZoom: 13,
  } as L.TileLayerOptions)
  .addTo(map);

// Set up tile saving controls
const control = L.control.savetiles(baseLayer, {
  position: "topright",
  zoomlevels: [13, 16],
  confirm: (layer: any, successCallback: () => void): void => {
    if (window.confirm(`Save ${layer._tilesforSave.length}`)) {
      successCallback();
    }
  },
  confirmRemoval: (layer: any, successCallback: () => void): void => {
    if (window.confirm("Remove all the tiles?")) {
      successCallback();
    }
  },
});

control.addTo(map);

// Set map view
map.setView({ lat: 51.985, lng: 5 }, 16);

// Add layers to map
const layerswitcher = L.control
  // @ts-expect-error the
  .layers({ "osm (offline)": baseLayer }, null, { collapsed: false })
  .addTo(map);

// GeoJSON storage layer
let storageLayer: L.GeoJSON;

// Get stored GeoJSON data
const getGeoJsonData = (): Promise<L.GeoJSON> =>
  // @ts-expect-error the
  LeafletOffline.getStorageInfo(urlTemplate).then((data: any) =>
    // @ts-expect-error the
    LeafletOffline.getStoredTilesAsJson(baseLayer, data),
  );

// Add storage layer to the map
const addStorageLayer = (): void => {
  getGeoJsonData().then((geojson: any) => {
    storageLayer = L.geoJSON(geojson).bindPopup(
      (clickedLayer: any) => clickedLayer.feature.properties.key,
    );
    layerswitcher.addOverlay(storageLayer, "stored tiles");
  });
};

addStorageLayer();

// Event listener to remove tiles
document.getElementById("remove_tiles")?.addEventListener("click", () => {
  (control as any)._rmTiles(); // Assuming _rmTiles is a method without typing in the library
});

// Update storage size event
baseLayer.on("storagesize", (e: any) => {
  document.getElementById("storage")!.innerHTML = e.storagesize.toString();
  if (storageLayer) {
    storageLayer.clearLayers();
    getGeoJsonData().then((data: any) => {
      storageLayer.addData(data);
    });
  }
});

// Progress tracking for saving tiles
let progress: number;
baseLayer.on("savestart", (e: any) => {
  progress = 0;
  document.getElementById("total")!.innerHTML =
    e._tilesforSave.length.toString();
});
baseLayer.on("savetileend", () => {
  progress += 1;
  document.getElementById("progress")!.innerHTML = progress.toString();
});

// File: src/utils/errorHandler.ts
import { NextResponse } from "next/server";

export const handleError = (err: Error, status: number = 500) => {
  console.error(err); // log the  error
  return NextResponse.json({ message: err.message }, { status: 500 });
};

// File: src/store/useModal.ts
import { IPoint } from "@/types";
import React from "react";
import { create } from "zustand";
import { devtools } from "zustand/middleware";

export type ModalData = {
  point?: IPoint;
};
interface IModal {
  isLoading: boolean;
  data: ModalData;
  isOpen: boolean;
  modal: React.ReactNode;
}
export type Actions = {
  setOpen: (modal: React.ReactNode, data?: ModalData) => void;
  setClose: () => void;
  setIsLoading: (state: (() => boolean) | boolean) => void;
};
export type Store = IModal & Actions;
const defaultValues: IModal = {
  isLoading: false,
  data: {},
  modal: null,
  isOpen: false,
};
export const useModal = create<Store>()(
  devtools((set, get) => ({
    ...defaultValues,
    setOpen: (modal, data) => {
      set({ modal, isOpen: true, data: { ...get().data, ...data } });
    },
    setClose: () => {
      set(defaultValues);
    },
    setIsLoading: (state) => {
      if (typeof state == "boolean") {
        return set({ isLoading: state });
      }
      return set({ isLoading: state() });
    },
  })),
);

// File: src/store/pointDataStore.ts

// File: src/store/store.ts
import { deleteData, getData, postData, putData } from "@/services/API";
import { ILine, IPoint, IPolygon, ISettings } from "@/types";
import { create } from "zustand";
import L, { polygon } from "leaflet";
interface IHistory {
  actionType: "create" | "delete" | "update";
  type: "polygon" | "polyline";
  polygon?: IPolygon;
  line?: ILine;
}
interface IFuture extends IHistory {
  layer: L.Layer;
}
interface dataType {
  map: L.Map | null;
  isLoading: boolean;
  points: IPoint[];
  polygons: IPolygon[]; // State for polygons
  lines: ILine[]; // New state for lines
  settings?: ISettings;
  addPointModal: boolean;
  showPointList: boolean;
  drawnItems?: L.FeatureGroup<any>;
  history: IHistory[]; // Array to track history for undo
  future: IFuture[]; // Array to track future for redo
}

interface storeAction {
  setDrawnItems: (drawnItems: L.FeatureGroup<any>) => void;
  setAddPointModal: (value: boolean) => void;
  setShowPointList: (value: boolean) => void;
  setPoints: (points: IPoint[]) => void;
  setPolygons: (polygons: IPolygon[]) => void; // Setter for polygons
  setLines: (lines: ILine[]) => void; // Setter for lines
  addLine: (line: ILine) => void; // Action to add a line
  getSettings: () => void;
  getAllPoints: () => void;
  refreshAllData: () => void;
  getAllPolygons: () => Promise<IPolygon[]>;
  getAllLines: () => Promise<ILine[]>;
  setIsLoading: (state: (() => boolean) | boolean) => void;
  setMap: (state: (() => L.Map | null) | (L.Map | null)) => void;
  pushToHistory: ({
    actionType,
    type,
    line,
    polygon,
  }: {
    actionType: "create" | "delete" | "update";
    type: "polygon" | "polyline";
    polygon?: IPolygon;
    line?: ILine;
  }) => void;
  undo: () => void;
  redo: () => void;
}

const initialData: dataType = {
  map: null,
  isLoading: false,
  addPointModal: false,
  points: [],
  polygons: [],
  lines: [],
  showPointList: false,
  history: [],
  future: [],
};

export type storeType = dataType & storeAction;

export const useAppStore = create<storeType>((set, get) => ({
  ...initialData,

  setAddPointModal: (value) => set(() => ({ addPointModal: value })),
  setShowPointList: (value) => set(() => ({ showPointList: value })),

  setPoints: (points) => set(() => ({ points })),
  setPolygons: (polygons) => set(() => ({ polygons })),
  setLines: (lines) => set(() => ({ lines })),

  addLine: (line) => set((state) => ({ lines: [...state.lines, line] })),

  getSettings: () => {
    set({ isLoading: true });
    getData("/api/settings", {}).then((res) => {
      set({ settings: res.data, isLoading: false });
    });
  },

  getAllPoints: () => {
    set({ isLoading: true });
    getData("/api/points", {})
      .then((res) => {
        set({ points: res.data, isLoading: false });
      })
      .catch((error) => {
        console.error("Error fetching points:", error);
        set({ isLoading: false });
      });
  },

  getAllPolygons: async () => {
    set({ isLoading: true });
    const res = await getData("/api/polygons", {});
    set({ polygons: res.data, isLoading: false });
    return res.data;
  },

  getAllLines: async () => {
    set({ isLoading: true });
    const res = await getData("/api/lines", {});
    set({ lines: res.data, isLoading: false });
    return res.data;
  },

  setIsLoading: (state) => {
    if (typeof state == "boolean") {
      set({ isLoading: state });
    } else if (typeof state == "function") {
      set({ isLoading: state() });
    }
  },

  setMap: (state) => {
    if (typeof state == "function") {
      set({ map: state() });
    } else {
      set({ map: state });
    }
  },

  refreshAllData: () => {
    get().getAllLines();
    get().getAllPoints();
    get().getAllPolygons();
    get().getSettings();
  },

  // Push state to history and reset future (for new actions)
  pushToHistory: ({ actionType, type, line, polygon }) => {
    console.log("addToHistory");
    const { history } = get();
    set({
      history: [...history, { actionType, type, line, polygon }],
      future: [],
    });
  },

  // Undo: Revert the last action and store it in future
  undo: () => {
    const {
      history,
      future,
      drawnItems,
      getAllLines,
      getAllPolygons,
      setIsLoading,
    } = get();
    if (history.length === 0 || !drawnItems) {
      return;
    }
    console.log(history);

    const lastAction = history[history.length - 1];

    let item: IPolygon | IPoint;
    if (lastAction.polygon) {
      item = lastAction.polygon;
    } else {
      // @ts-expect-error the
      item = lastAction.line!;
    }

    const layer = drawnItems
      .getLayers()
      // @ts-expect-error the
      .findLast((layer) => layer.options.id == item._id);
    if (!layer) {
      return;
    }
    const updatedHistory = history.slice(0, -1);
    set({
      history: updatedHistory,
      future: [{ ...lastAction, layer }, ...future],
    });

    switch (lastAction.actionType) {
      case "create":
        console.log("fuck");
        drawnItems.removeLayer(layer);
        if (lastAction.type == "polygon") {
          deleteData("/api/polygons", { id: item._id }).then(() => {
            getAllPolygons();
            setIsLoading(false);
          });
        } else if (lastAction.type == "polyline") {
          deleteData("/api/lines", { id: item._id }).then(() => {
            getAllLines();
            setIsLoading(false);
          });
        }

        break;
      case "delete":
      case "update":
    }
  },

  // Redo: Reapply the last undone action
  redo: () => {
    const {
      future,
      history,
      drawnItems,
      getAllPolygons,
      getAllLines,
      setIsLoading,
    } = get();
    if (future.length === 0 || !drawnItems) {
      return;
    }

    const nextAction = future[0];
    let item: IPolygon | IPoint;
    if (nextAction.polygon) {
      item = nextAction.polygon;
    } else {
      // @ts-expect-error the
      item = nextAction.line!;
    }
    const updatedFuture = future.slice(1);
    set({
      future: updatedFuture,
      history: [
        ...history,
        {
          type: nextAction.type,
          actionType: nextAction.actionType,
          line: nextAction.line,
          polygon: nextAction.polygon,
        },
      ],
    });

    switch (nextAction.actionType) {
      case "create":
        drawnItems.addLayer(nextAction.layer);
        if (nextAction.type == "polygon") {
          putData("/api/polygons", { id: item._id, deletedAt: null }).then(
            () => {
              getAllPolygons();
              setIsLoading(false);
            },
          );
        } else if (nextAction.type == "polyline") {
          putData("/api/lines", { id: item._id, deletedAt: null }).then(() => {
            getAllLines();
            setIsLoading(false);
          });
        }
        break;
      case "delete":
      case "update":
    }
  },
  setDrawnItems: (drawnItems) => {
    set({ drawnItems });
  },
}));

// File: src/css/style.css
.leaflet-container,
.leaflet {
  width: 100%;
  height: 100%;
}

@keyframes spinner {
  0% {
    transform: rotate(0);
  }

  100% {
    transform: rotate(360deg);
  }
}

.spinner-anim {
  animation: spinner 1s infinite;
}
.leaflet-top {
  display: flex; /* Use flexbox to arrange the buttons horizontally */
  flex-direction: row-reverse; /* Arrange the buttons in a row (horizontal) */
  box-shadow: none;
}
.leaflet-control-zoom {
  gap: 3px;
  display: flex; /* Use flexbox to arrange the buttons horizontally */
  flex-direction: row; /* Arrange the buttons in a row (horizontal) */
}
.leaflet-draw {
  gap: 3px;
  display: flex; /* Use flexbox to arrange the buttons horizontally */
  flex-direction: row; /* Arrange the buttons in a row (horizontal) */
}
.leaflet-draw-section {
  gap: 3px;
  display: flex; /* Use flexbox to arrange the buttons horizontally */
  flex-direction: row; /* Arrange the buttons in a row (horizontal) */
}
.leaflet-draw-toolbar {
  gap: 3px;
  display: flex; /* Use flexbox to arrange the buttons horizontally */
  flex-direction: row; /* Arrange the buttons in a row (horizontal) */
}
.leaflet-draw-toolbar {
  margin-top: 0px;
}
.savetiles {
  gap: 3px;
  display: flex; /* Use flexbox to arrange the buttons horizontally */
  flex-direction: row; /* Arrange the buttons in a row (horizontal) */
}
.leaflet-draw-actions {
  margin-top: 35px;
}

// File: src/types/index.ts
// File: src/types/index.ts

export interface IPoint {
  _id: string;
  name: string;
  lat: number;
  lng: number;
  frequency: number;
  iconType: string;
  date: string;
  active: boolean;
  status: boolean;
  port: number;
  requireData: string[];

  connect: boolean;
  level: number;
}

export interface ISettings {
  lat: number;
  lng: number;
  zoom: number;
  PointIcon: { name: string; url: string }[];
}
export interface ILine {
  _id: string;
  startPoint: { lat: number; lng: number };
  endPoint: { lat: number; lng: number };
  length: number;
  angle: number;
}

export interface IFormData {
  name: string;
  lat: string;
  lng: string;
  frequency: string;
  lat_settings?: string;
  lng_settings?: string;
  zoom?: string;
  search?: string;
}

// New IPolygon interface for polygons
export interface IPolygon {
  _id: string;
  name: string;
  points: { lat: number; lng: number }[]; // Array of lat/lng for polygon vertices
  flag: number; // 0 (hide) or 1 (show)
  isPolygon: boolean; // True for polygons
  date: string;
}

export interface IModalProps {
  isOpen: boolean;
  onClose: () => void;
  onSubmit: (data: IFormData) => void;
  loading: boolean;
  initialData?: IFormData;
}

export interface MapComponentProps {
  points: IPoint[];
  polygons: IPolygon[]; // Add polygons to map component props
  settings: ISettings;
  onMarkerClick: (point: IPoint) => void;
}

// File: src/types/leaflet-offline.d.ts
import "leaflet";

declare module "leaflet" {
  namespace tileLayer {
    function offline(
      urlTemplate: string,
      options?: L.TileLayerOptions,
    ): L.TileLayer;
  }

  namespace control {
    function savetiles(layer: L.TileLayer, options: any): L.Control;
  }
}

interface LeafletOffline {
  getStorageInfo(urlTemplate: string): Promise<any[]>;
  getStoredTilesAsJson(layer: L.TileLayer, data: any[]): Promise<L.GeoJSON>;
}
declare module "leaflet" {
  interface LeafletEvent {
    _tilesforSave?: any[]; // Define the custom property _tilesforSave, change `any[]` to a more specific type if known
  }
}

// File: src/validator/index.ts
import { z } from "zod";

export const pointObject = z.object({
  name: z.string().min(2, {
    message: "Username must be at least 2 characters.",
  }),
  lat: z.number(),
  lng: z.number(),
  frequency: z.number(),
  iconType: z.string(),
  active: z.boolean(),
  status: z.boolean(),
  port: z.number(),
  requireData: z.array(z.string()),
  connect: z.boolean(),
  level: z.number(),
});
export const settingsObject = z.object({
  lat_settings: z.number().min(-90).max(90), // Validation for lat
  lng_settings: z.number().min(-180).max(180), // Validation for lng
  zoom: z
    .number()
    .min(0, { message: "Zoom must be at least 0" })
    .max(22, { message: "Zoom must be at most 22" }), // Validation for zoom
  file: z.instanceof(FileList).optional(),
});

// File: src/components/global/pointAction.tsx
"use client";
import { Tooltip } from "@nextui-org/react";
import React from "react";
import { Modals } from "../modals";
import { PointForm } from "../forms/pointForm";
import { useModal } from "@/store/useModal";
import { IPoint } from "@/types";
import { DeletePointModal } from "../modals/deletePointModal";
import { EditIcon, Trash2 } from "lucide-react";

export const PointAction = ({ data }: { data: IPoint }) => {
  const setOpen = useModal((state) => state.setOpen);
  return (
    <div className="relative flex items-center gap-4">
      <Tooltip content="edit point">
        <button
          onClick={() =>
            setOpen(
              <Modals title="edit point">
                <PointForm type="edit"></PointForm>
              </Modals>,
              { point: data },
            )
          }
          className="cursor-pointer text-lg text-default-400 active:opacity-50"
        >
          <EditIcon />
        </button>
      </Tooltip>

      <Tooltip color="danger" content="delete point">
        <button
          onClick={() =>
            setOpen(<DeletePointModal data={data}></DeletePointModal>)
          }
          className="cursor-pointer text-lg text-danger active:opacity-50"
        >
          <Trash2 />
        </button>
      </Tooltip>
    </div>
  );
};

// File: src/components/modals/downloadModal.tsx
"use client";
import React, { useEffect } from "react";
import { Modals } from ".";
import { ModalBody, ModalFooter, Spinner } from "@nextui-org/react";
import { useModal } from "@/store/useModal";
export const DownloadModal = ({
  total,
  progress,
}: {
  total: number;
  progress: number;
}) => {
  const setClose = useModal((state) => state.setClose);
  useEffect(() => {
    if (total == progress) {
      setClose();
    }
  }, [total, progress]);
  return (
    <Modals title={"delete point"}>
      <ModalBody>
        <div className="flex w-full items-center justify-between gap-2 text-sm">
          <span>Total Tiles : {total}</span>
          <span>Downloaded Tiles : {progress}</span>

          {/* <div className="h-5 w-full rounded-full bg-gray-200">
            <div
              style={{ width: `${total / progress}%` }}
              className="flex h-full items-center justify-center rounded-full bg-indigo-600 text-xs text-white"
            >
              {progress}%
            </div>
          </div> */}
        </div>
      </ModalBody>
      <ModalFooter>
        <div className="flex w-full justify-center gap-4">
          <Spinner size="sm" label="Please wait..." />
        </div>
      </ModalFooter>
    </Modals>
  );
};

// File: src/components/modals/index.tsx
"use client";
import { Modal, ModalContent, ModalHeader } from "@nextui-org/react";
import { useModal } from "@/store/useModal";
export function Modals({
  children,
  title,
}: {
  children: React.ReactNode;
  title: string;
}) {
  const { isOpen, setClose } = useModal((state) => state);
  return (
    <Modal
      classNames={{ backdrop: "z-[999]", wrapper: "z-[9999]" }}
      isOpen={isOpen}
      onClose={() => setClose()}
    >
      <ModalContent>
        {() => (
          <>
            <ModalHeader className="flex flex-col gap-1">{title}</ModalHeader>
            {children}
          </>
        )}
      </ModalContent>
    </Modal>
  );
}

// File: src/components/modals/deletePointModal.tsx
"use client";
import React from "react";
import { Modals } from ".";
import { useModal } from "@/store/useModal";
import { deleteData } from "@/services/API";
import { IPoint } from "@/types";
import { Button, ModalBody, ModalFooter } from "@nextui-org/react";
import { useAppStore } from "@/store/store";
import { shutdownWorker } from "@/helper/workerManager";

export const DeletePointModal = ({
  data,
  url = "/api/points",
}: {
  data: IPoint;
  url?: string;
}) => {
  const setClose = useModal((state) => state.setClose);
  const getAllPoints = useAppStore((state) => state.getAllPoints);
  const setIsLoading = useModal((state) => state.setIsLoading);
  const isLoading = useModal((state) => state.isLoading);
  const deletePointHandler = () => {
    setIsLoading(true);
    if (!data.connect) {
      shutdownWorker(data._id);
    }
    deleteData(url, { id: data._id }).then(() => {
      getAllPoints();
      setIsLoading(false);
      setClose();
    });
  };
  return (
    <Modals title={"delete point"}>
      <ModalBody>
        <div className="flex w-full gap-2">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            strokeWidth="1.5"
            stroke="currentColor"
            className="size-7 text-red-600"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              d="M12 9v3.75m-9.303 3.376c-.866 1.5.217 3.374 1.948 3.374h14.71c1.73 0 2.813-1.874 1.948-3.374L13.949 3.378c-.866-1.5-3.032-1.5-3.898 0L2.697 16.126ZM12 15.75h.007v.008H12v-.008Z"
            />
          </svg>

          <span>Are you sure you want to delete this point?</span>
        </div>
      </ModalBody>
      <ModalFooter>
        <div className="flex w-full justify-center gap-4">
          <Button
            color="danger"
            variant="light"
            type="button"
            onClick={() => setClose()}
          >
            Close
          </Button>
          <Button
            isLoading={isLoading}
            variant="shadow"
            className="bg-red-500 text-white shadow-green-200"
            onClick={deletePointHandler}
          >
            remove point
          </Button>
        </div>
      </ModalFooter>
    </Modals>
  );
};

// File: src/components/map/Table.tsx
"use client";
import React, { useState } from "react";
import {
  Chip,
  Spinner,
  Table,
  TableBody,
  TableCell,
  TableColumn,
  TableHeader,
  TableRow,
} from "@nextui-org/react";
import { PointAction } from "../global/pointAction";
import { IPoint } from "@/types";
import { useAppStore } from "@/store/store";
import { postData } from "@/services/API";
export const statusColorMap: { [key: string]: "success" | "danger" } = {
  active: "success",
  disable: "danger",
};
const columns = [
  { name: "id", uid: "id" },
  { name: "name", uid: "name" },
  { name: "lat", uid: "lat" },
  { name: "lng", uid: "lng" },
  { name: "frequency", uid: "frequency" },
  { name: "status", uid: "status" },
  { name: "time", uid: "time" },
  { name: "", uid: "action" },
];
export const Tables = () => {
  const { points, isLoading, getAllPoints } = useAppStore((state) => state);
  const [statusLoading, setStatusLoading] = useState(false);
  const changeStatusHandler = (id: string) => {
    setStatusLoading(true);
    postData("/api/points/change-status", { id }).then(() => {
      setStatusLoading(false);
      getAllPoints();
    });
  };

  const renderCell = (point: IPoint, columnKey: string, id: string) => {
    const cellValue = point[columnKey as keyof IPoint];

    switch (columnKey) {
      case "id":
        return <span>{id}</span>;
      case "name":
      case "lat":
      case "lng":
      case "frequency":
        return (
          <div className="flex flex-col">
            <p className="text-sm font-bold text-gray-700">
              {point[columnKey]}
            </p>
          </div>
        );
      case "status":
        return (
          <button onClick={() => changeStatusHandler(point._id)}>
            <Chip
              className="capitalize"
              color={statusColorMap[point.status ? "active" : "disable"]}
              size="sm"
              variant="flat"
            >
              {statusLoading ? "wait..." : point.status ? "active" : "disable"}
            </Chip>
          </button>
        );
      case "time":
        return (
          <div className="flex flex-col">
            <p className="text-sm font-bold capitalize text-gray-700">
              {new Date(point.date).toLocaleString()}
            </p>
          </div>
        );
      case "action":
        return <PointAction data={point}></PointAction>;
      default:
        return cellValue ? <span>{cellValue}</span> : null;
    }
  };
  return (
    <Table
      classNames={{ wrapper: "bg-transparent shadow-none rounded-none" }}
      className="max-h-fit overflow-scroll"
      aria-label="Example table with custom cells"
    >
      <TableHeader columns={columns}>
        {(column) => (
          <TableColumn key={column.uid} align="center">
            {column.name}
          </TableColumn>
        )}
      </TableHeader>
      <TableBody
        loadingContent={<Spinner label="Loading..." />}
        isLoading={isLoading}
        items={points}
        emptyContent="doesn't exist any point  !"
      >
        {(item) => (
          <TableRow key={item._id}>
            {(columnKey) => (
              <TableCell>
                {renderCell(
                  item,
                  //@ts-expect-error the
                  columnKey,
                  points.findIndex((p) => p._id === item._id) + 1,
                )}
              </TableCell>
            )}
          </TableRow>
        )}
      </TableBody>
    </Table>
  );
};

// File: src/components/map/toolbar.tsx
"use client";
import {
  Button,
  DateRangePicker,
  DateValue,
  Input,
  RangeValue,
  Spinner,
  TimeInput,
  TimeInputValue,
} from "@nextui-org/react";
import React, { useState } from "react";
import { Modals } from "../modals";
import { SettingsForm } from "../forms/settingsForm";
import { useForm } from "react-hook-form";
import { useAppStore } from "@/store/store";
import { useModal } from "@/store/useModal";
import {
  RedoIcon,
  RefreshCw,
  SearchIcon,
  Settings,
  UndoIcon,
  X,
} from "lucide-react";

export const Toolbar = () => {
  const {
    points,
    getAllPoints,
    isLoading,
    setPoints,
    refreshAllData,
    undo,
    redo,
  } = useAppStore((state) => state);
  const { setOpen } = useModal((state) => state);

  const { register, setValue, watch } = useForm({
    mode: "onBlur",
    defaultValues: {
      search: "",
    },
  });

  const [date, setDate] = useState<RangeValue<DateValue>>();
  const [from, setFrom] = useState<TimeInputValue>();
  const [to, setTo] = useState<TimeInputValue>();
  const searchVal = watch("search");
  const searchPointsHandler = () => {
    if (!searchVal) {
      getAllPoints(); // Reset points to default if no search value
      return;
    }
    const filteredPoints = points.filter((data) =>
      data.name.toLowerCase().includes(searchVal.toLowerCase()),
    );

    setPoints(filteredPoints);
  };

  // Date and Time Filter Handler
  const sortByDateHandler = () => {
    if (!date?.start || !date?.end) {
      return;
    }
    //@ts-expect-error the
    const startDate = new Date(date.start); //@ts-expect-error the
    const endDate = new Date(date.end);
    const filteredPoints = points.filter((point) => {
      const pointDate = new Date(point.date);
      const isWithinDateRange = pointDate >= startDate && pointDate <= endDate;
      if (from && to) {
        const pointTime = `${pointDate.getHours()}:${pointDate.getMinutes()}`;
        const fromTime = `${from.hour}:${from.minute}`;
        const toTime = `${to.hour}:${to.minute}`;

        return (
          isWithinDateRange && pointTime >= fromTime && pointTime <= toTime
        );
      }
      return isWithinDateRange;
    });
    setPoints(filteredPoints);
  };

  return (
    <div className="flex w-full items-center justify-between px-4 pb-1">
      <div className="toolbar-buttons">
        {/* Other buttons */}
        <button onClick={undo}>
          <UndoIcon /> Undo
        </button>
        <button onClick={redo}>
          <RedoIcon /> Redo
        </button>
      </div>
      <div className="flex justify-center gap-16">
        <Input
          isRequired
          className="w-80"
          labelPlacement="outside"
          placeholder="search point..."
          value={searchVal}
          {...register("search")}
          endContent={
            <div className="flex gap-3">
              {searchVal?.length > 0 && (
                <button
                  onClick={() => {
                    setValue("search", "");
                    searchPointsHandler();
                  }}
                >
                  <X />
                </button>
              )}
              <button onClick={searchPointsHandler}>
                <SearchIcon size={20}></SearchIcon>
              </button>
            </div>
          }
          size="md"
        />
      </div>

      <div className="flex flex-row-reverse gap-4">
        <DateRangePicker
          aria-label="filter by date"
          value={date}
          onChange={(x) => setDate(x)}
          hideTimeZone
          defaultValue={date}
        />
        <TimeInput
          label="from"
          value={from}
          onChange={setFrom}
          labelPlacement="outside-left"
        />
        <TimeInput
          label="to"
          value={to}
          onChange={setTo}
          labelPlacement="outside-left"
        />
        <Button
          onClick={sortByDateHandler}
          variant="shadow"
          className="bg-indigo-600 text-white shadow-indigo-200"
        >
          Filter
        </Button>
        {date?.start && (
          <button
            onClick={() => {
              setDate(undefined); // Reset date
              setFrom(undefined);
              setTo(undefined);
              getAllPoints(); // Reset points list
            }}
          >
            <X />
          </button>
        )}
      </div>

      <div className="flex flex-row-reverse items-center gap-4">
        {/* Settings Button */}
        <button
          onClick={() =>
            setOpen(
              <Modals title="edit point">
                <SettingsForm></SettingsForm>
              </Modals>,
            )
          }
          className="flex size-10 items-center justify-center rounded-xl bg-red-600 text-white shadow-lg shadow-red-200 outline-none transition-all duration-300 active:scale-95"
        >
          {isLoading ? <Spinner size="sm" color="white" /> : <Settings />}
        </button>

        <button
          onClick={() => {
            refreshAllData();
          }}
          className="flex size-10 items-center justify-center rounded-xl bg-gray-100 text-gray-600 shadow-lg shadow-gray-200 transition-all duration-300 active:scale-95"
        >
          <RefreshCw />
        </button>
      </div>
    </div>
  );
};

// File: src/components/map/Map.tsx
"use client";

import React, { useEffect, useState } from "react";
import { MapContainer, TileLayer } from "react-leaflet";
import { Spinner } from "@nextui-org/react";
import { useAppStore } from "@/store/store";
import { IPoint } from "@/types";
import { ModalProvider } from "@/providers/ModalProvider";
import { useModal } from "@/store/useModal";
import { Modals } from "../modals";
import { PointForm } from "../forms/pointForm";
import { Tables } from "./Table";
import { Toolbar } from "./toolbar";
import MarkerClusterGroup from "react-leaflet-cluster";
import { DownloadModal } from "../modals/downloadModal";
import { Mark } from "./mark";
import { Draw } from "@/helper/draw";
import "leaflet.offline";
import "leaflet-draw";
import L from "leaflet";
import { controlSaveTiles } from "@/helper/controlSaveTiles";
export default function Map() {
  const [progress, setProgress] = useState(0);
  const [total, setTotal] = useState(0);
  const {
    showPointList,
    points,
    settings,
    isLoading,
    setMap,
    refreshAllData,
    map,
  } = useAppStore((state) => state);
  const { setOpen, modal } = useModal((state) => state);
  const [pointLabel, setPointLabel] = useState<Partial<IPoint>>({});
  const [once, setOnce] = useState(true);

  // Fetch all points
  useEffect(() => {
    if (!map) {
      return;
    }
    if (once) {
      setOnce(false);
      refreshAllData();

      if (map) {
        new L.Control.Zoom({
          position: "topright",
        }).addTo(map);

        Draw(map);
        map.on("dblclick", (e: L.LeafletMouseEvent) => {
          const { lat, lng } = e.latlng;
          setOpen(
            <Modals title="Create Point">
              <PointForm type="create" />
            </Modals>,
            // @ts-expect-error thee
            { point: { name: "", lat: lat, lng: lng, frequency: 0 } },
          );
        });
        controlSaveTiles({ map, setProgress, setTotal });
      }
    }
  }, [map]);
  useEffect(() => {
    if (progress > 0 && total > 0 && !modal) {
      setOpen(
        <DownloadModal progress={progress} total={total}></DownloadModal>,
      );
    }
  }, [progress, total]);

  return (
    <div className="flex size-full flex-col">
      <ModalProvider></ModalProvider>
      <div className={"relative size-full"}>
        <MapContainer
          center={
            settings?.lat
              ? [settings.lat, settings.lng]
              : [35.695246913723636, 51.41011318883557]
          }
          zoom={settings?.zoom ? settings?.zoom : 13}
          scrollWheelZoom={true}
          zoomControl={false}
          doubleClickZoom={false}
          ref={setMap}
        >
          <TileLayer
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          />
          {isLoading ? (
            <div className="relative z-[999] flex size-full items-center justify-center bg-transparent">
              <Spinner label="please wait..." />
            </div>
          ) : (
            <>
              <MarkerClusterGroup>
                {points.length > 0 &&
                  points.map(
                    (point) =>
                      point.status && (
                        <Mark
                          key={point._id}
                          point={point}
                          setPointLabel={setPointLabel}
                        ></Mark>
                      ),
                  )}
              </MarkerClusterGroup>
            </>
          )}
        </MapContainer>
        {pointLabel?.lat && (
          <div
            className={
              "absolute bottom-4 right-4 z-[999] flex flex-col gap-1 rounded-lg bg-white p-2 text-xs transition-all duration-300"
            }
          >
            <span>lat: {pointLabel?.lat}</span>
            <span>lng: {pointLabel?.lng}</span>
          </div>
        )}
      </div>

      <div
        className={`mt-3 flex w-full flex-col  ${
          showPointList ? "h-2/5" : "h-0 overflow-hidden"
        } transition-all duration-300`}
      >
        <Toolbar></Toolbar>
        <Tables></Tables>
      </div>
    </div>
  );
}

// File: src/components/map/PointIcon.tsx
import { useAppStore } from "@/store/store";
import L from "leaflet";

export const getPointIcon = (iconType: string) => {
  const icon = useAppStore
    .getState()
    .settings?.PointIcon.find((val) => val.name == iconType);

  return L.icon({
    iconUrl: icon?.url || "/assets/icon.png",
    iconSize: [32, 32],
  });
};

// File: src/components/map/mark.tsx
"use client";

import { EditIcon, Trash2 } from "lucide-react";
import React, { useEffect } from "react";
import { Marker, Popup, Tooltip } from "react-leaflet";
import { Modals } from "../modals";
import { DeletePointModal } from "../modals/deletePointModal";
import { PointForm } from "../forms/pointForm";
import { postData } from "@/services/API";
import { IPoint } from "@/types";
import { getPointIcon } from "./PointIcon"; // Adjusted import
import { useAppStore } from "@/store/store";
import { useModal } from "@/store/useModal";
import { startPointWorker } from "@/helper/workerManager";

import L from "leaflet";
let currentLine: L.Polyline<any>;
export const Mark = ({
  point,
  setPointLabel,
}: {
  point: IPoint;
  setPointLabel: React.Dispatch<React.SetStateAction<Partial<IPoint>>>;
}) => {
  const { getAllPoints, map } = useAppStore((state) => state);
  const { setOpen } = useModal((state) => state);

  // State to hold the single line to display

  const changeStatusHandler = (id: string) => {
    postData("/api/points/change-status", { id }).then(() => {
      getAllPoints();
    });
  };

  // Function to calculate the new point based on the angle and distance
  const calculateEndpoint = (
    lat: number,
    lng: number,
    angle: number,
    distance: number = 1000, // 1 km
  ): [number, number] => {
    const R = 6371000; // Radius of the Earth in meters
    const angularDistance = distance / R; // Angular distance in radians
    const angleRad = (angle * Math.PI) / 180; // Convert the angle to radians

    const newLat = Math.asin(
      Math.sin((lat * Math.PI) / 180) * Math.cos(angularDistance) +
        Math.cos((lat * Math.PI) / 180) *
          Math.sin(angularDistance) *
          Math.cos(angleRad),
    );

    const newLng =
      ((lng * Math.PI) / 180 +
        Math.atan2(
          Math.sin(angleRad) *
            Math.sin(angularDistance) *
            Math.cos((lat * Math.PI) / 180),
          Math.cos(angularDistance) -
            Math.sin((lat * Math.PI) / 180) * Math.sin(newLat),
        )) *
      (180 / Math.PI);

    return [newLat * (180 / Math.PI), newLng];
  };

  useEffect(() => {
    if (point.connect) {
      startPointWorker(point._id, point.port, point.requireData);
    }
  }, [point.connect]);
  return (
    <>
      <Marker
        key={point._id}
        icon={getPointIcon(point.iconType)} // Adjusted to pass correct icon type
        position={[point.lat, point.lng]}
        eventHandlers={{
          mouseover: () => {
            setPointLabel(point);
          },
          mouseout: () => {
            setPointLabel({});
          },
          click: () => {
            // Remove the existing line before adding a new one

            // Calculate the endpoint for the new line based on the point's angle
            const endPoint = calculateEndpoint(
              point.lat,
              point.lng,
              point.level,
            );

            // Create a new line from the point to the calculated endpoint
            if (currentLine) {
              map?.removeLayer(currentLine); // Remove the existing line
            }
            currentLine = L.polyline([[point.lat, point.lng], endPoint], {
              color: "blue",
            }).addTo(map!); // Add new line to the map
          },
        }}
      >
        <Tooltip direction="bottom" offset={[0, 10]} permanent>
          {point.name}
        </Tooltip>
        <Popup>
          <div className="flex w-full flex-col gap-1">
            <span>name: {point.name}</span>
            <span>lat: {point.lat}</span>
            <span>lng: {point.lng}</span>
            <span>frequency: {point.frequency}</span>
            <span>status: {point.status}</span>

            <div className="mt-2 flex w-full items-center justify-center gap-3">
              <button
                onClick={() =>
                  setOpen(
                    <Modals title="edit point">
                      <PointForm type="edit"></PointForm>
                    </Modals>,
                    { point },
                  )
                }
                className="cursor-pointer text-lg text-default-400 active:opacity-50"
              >
                <EditIcon />
              </button>

              <button
                onClick={() =>
                  setOpen(
                    <DeletePointModal
                      data={point}
                      url="/api/points/del"
                    ></DeletePointModal>,
                  )
                }
                className="cursor-pointer text-lg text-danger active:opacity-50"
              >
                <Trash2 />
              </button>

              <button
                onClick={() => changeStatusHandler(point._id)}
                className="cursor-pointer text-lg text-warning active:opacity-50"
              >
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  strokeWidth="1.5"
                  stroke="currentColor"
                  className="size-5"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    d="M3.98 8.223A10.477 10.477 0 0 0 1.934 12C3.226 16.338 7.244 19.5 12 19.5c.993 0 1.953-.138 2.863-.395M6.228 6.228A10.451 10.451 0 0 1 12 4.5c4.756 0 8.773 3.162 10.065 7.498a10.522 10.522 0 0 1-4.293 5.774M6.228 6.228 3 3m3.228 3.228 3.65 3.65m7.894 7.894L21 21m-3.228-3.228-3.65-3.65m0 0a3 3 0 1 0-4.243-4.243m4.242 4.242L9.88 9.88"
                  />
                </svg>
              </button>
            </div>
          </div>
        </Popup>
      </Marker>
    </>
  );
};

// File: src/components/sidebar/chart.tsx
import React, { useEffect } from "react";
// @ts-expect-error the
import Plotly from "plotly.js-dist";
import { IPoint } from "@/types";

export const Chart = ({ point }: { point: IPoint }) => {
  useEffect(() => {
    // Example data
    // @ts-expect-error the
    const time = [...Array(300).keys()];
    const angle = Array.from({ length: 300 }, () => Math.random() * 360);
    // Line plot for Angle vs Time
    const lineplotData = [
      {
        x: time,
        y: angle,
        type: "scatter",
        mode: "lines",
        line: { color: "black" },
      },
    ];

    const lineplotLayout = {
      title: "Angle over Time",
      xaxis: { title: "Time (sec)" },
      yaxis: { title: "Angle (degrees)" },
    };

    Plotly.newPlot("lineplot", lineplotData, lineplotLayout);
  }, []); // Empty dependency array ensures this runs only once after the component mounts

  return (
    <div>
      <div id="lineplot" style={{ width: "345px", height: "300px" }}></div>
    </div>
  );
};

// File: src/components/sidebar/SidebarPoint.tsx
import React from "react";
import {
  Accordion,
  AccordionContent,
  AccordionItem,
  AccordionTrigger,
} from "../ui/accordion";
import { IPoint } from "@/types";
import { putData } from "@/services/API";
import { Chip } from "@nextui-org/react";
import { statusColorMap } from "../map/Table";
import { shutdownWorker } from "@/helper/workerManager";
import { Chart } from "./chart";

export const SidebarPoint = ({
  points,
  openSidebar,
  getAllPoints,
}: {
  points: IPoint[];
  openSidebar: boolean;
  getAllPoints: () => void;
}) => {
  const changeStatusHandler = (id: string, data: Partial<IPoint>) => {
    if (!data.connect) {
      shutdownWorker(id);
    }
    putData("/api/points", { id, ...data }).then(() => {
      getAllPoints();
    });
  };
  return (
    <div
      className={`${openSidebar ? "" : "hidden"} my-5 max-h-[700px] overflow-y-scroll`}
    >
      <Accordion type="single" collapsible>
        {points.map((point) => (
          <AccordionItem key={point._id} value={point._id}>
            <AccordionTrigger className="my-1 h-10 rounded-xl bg-slate-100">
              <div className="flex flex-row ">
                <div className="ml-2 text-sm font-medium">
                  name: {point.name}
                </div>
              </div>
            </AccordionTrigger>
            <AccordionContent className="rounded-xl bg-slate-100 pb-0">
              <div className="flex w-full flex-col text-lg">
                <div className="flex h-12 items-center border-b-1">
                  <div className="flex flex-col pl-2 text-sm">
                    <span className="font-semibold">Lat: </span>
                    {point.lat}
                  </div>

                  <div className="px-2 text-sm">
                    <span className="font-semibold">status: </span>
                    <button
                      onClick={() =>
                        changeStatusHandler(point._id, {
                          status: !point.status,
                        })
                      }
                    >
                      <Chip
                        className="capitalize"
                        color={
                          statusColorMap[point.status ? "active" : "disable"]
                        }
                        size="sm"
                        variant="flat"
                      >
                        {point.status ? "active" : "disable"}
                      </Chip>
                    </button>
                  </div>
                  <div className="flex flex-row items-center  text-sm">
                    Degree:{" "}
                    <svg
                      width="20px"
                      height="20px"
                      viewBox="0 0 100 100"
                      role="img"
                      preserveAspectRatio="xMidYMid meet"
                      style={{ rotate: `${point.level}deg` }}
                    >
                      <circle
                        r="45"
                        cx="50"
                        cy="50"
                        className="fill-transparent"
                        stroke="black"
                        strokeWidth="5"
                      ></circle>
                      <path
                        d="M50.03 5a2.516 2.516 0 0 0-2.43 1.76L34.493 48.548a2.51 2.51 0 0 0-.372 1.454c-.026.51.104 1.017.372 1.452l13.105 41.782c.737 2.352 4.065 2.352 4.802 0l13.105-41.785c.27-.436.399-.945.372-1.456a2.513 2.513 0 0 0-.372-1.45L52.401 6.76A2.513 2.513 0 0 0 50.03 5zM39.403 50.288h6.205c.152 2.306 2.048 4.134 4.392 4.134c2.344 0 4.24-1.828 4.392-4.134h6.461L50 84.078z"
                        fill="#000000"
                      ></path>
                    </svg>
                  </div>
                </div>

                <div className="flex h-10 items-center border-b-1">
                  <div className="flex flex-col pl-2 text-sm">
                    <span className="font-semibold">Lng: </span>
                    <span>{point.lng}</span>
                  </div>
                  <div className="px-2 text-sm">
                    <span className="font-semibold">connect: </span>
                    <button
                      onClick={() =>
                        changeStatusHandler(point._id, {
                          connect: !point.connect,
                        })
                      }
                    >
                      <Chip
                        className="capitalize"
                        color={
                          statusColorMap[point.connect ? "active" : "disable"]
                        }
                        size="sm"
                        variant="flat"
                      >
                        {point.connect ? "connect" : "disconnect"}
                      </Chip>
                    </button>
                  </div>
                </div>
                <div className="flex h-10 items-center gap-4 px-2">
                  <div className="pr-2 text-sm">
                    <span className="font-semibold">Frequency: </span>
                    {point.frequency}
                  </div>
                  <div className="pl-2 text-sm">
                    <span className="font-semibold">active: </span>
                    <button
                      onClick={() =>
                        changeStatusHandler(point._id, {
                          active: !point.active,
                        })
                      }
                    >
                      <Chip
                        className="capitalize"
                        color={
                          statusColorMap[point.active ? "active" : "disable"]
                        }
                        size="sm"
                        variant="flat"
                      >
                        {point.active ? "active" : "disable"}
                      </Chip>
                    </button>
                  </div>
                </div>
                <Chart point={point}></Chart>
              </div>
            </AccordionContent>
          </AccordionItem>
        ))}
      </Accordion>
    </div>
  );
};

// File: src/components/sidebar/Sidebar.tsx
"use client";
import React, { useState } from "react";
import Image from "next/image";
import { useModal } from "@/store/useModal";
import { Modals } from "../modals";
import { PointForm } from "../forms/pointForm";
import { useAppStore } from "@/store/store";
import { Eye, EyeOff, Menu } from "lucide-react";
import { SidebarPoint } from "./SidebarPoint";

export default function Sidebar() {
  const setOpen = useModal((state) => state.setOpen);
  const [openSidebar, setOpenSidebar] = useState(false);
  const { showPointList, setShowPointList, points, getAllPoints } = useAppStore(
    (state) => state,
  );
  return (
    <div
      className={`${openSidebar ? "min-w-96" : "min-w-16"} relative  overflow-y-scroll transition-all duration-300`}
    >
      <div
        className={`${openSidebar ? "min-w-96 p-5" : "min-w-16 p-2"} fixed bottom-0 flex h-full flex-col justify-between  gap-4 bg-indigo-100 pt-3 transition-all duration-300`}
      >
        <div>
          <div
            className={`${openSidebar ? "flex-row" : "flex-col-reverse gap-4"} flex  justify-between`}
          >
            <Image
              src="/assets/logo.png"
              width={0}
              height={0}
              sizes="100vw"
              className={"w-10 object-cover"}
              alt=""
              priority
            />
            <button
              onClick={() => setOpenSidebar(!openSidebar)}
              className="flex size-10 items-center justify-center rounded-xl bg-indigo-200 text-indigo-600 "
            >
              <Menu></Menu>
            </button>
          </div>
          <SidebarPoint
            points={points}
            openSidebar={openSidebar}
            getAllPoints={getAllPoints}
          ></SidebarPoint>
        </div>
        <div className="">
          <button
            onClick={() =>
              setOpen(
                <Modals title="add new point">
                  <PointForm></PointForm>
                </Modals>,
              )
            }
            className={`${openSidebar ? "h-10 w-full px-4" : "size-10  justify-center"} my-3 flex items-center gap-2 overflow-hidden rounded-xl bg-indigo-200 font-bold text-indigo-600 transition-all duration-300`}
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              fill="none"
              viewBox="0 0 24 24"
              strokeWidth="1.5"
              stroke="currentColor"
              className={`${openSidebar ? "size-6" : "size-5"}`}
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M15 10.5a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z"
              />
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                d="M19.5 10.5c0 7.142-7.5 11.25-7.5 11.25S4.5 17.642 4.5 10.5a7.5 7.5 0 1 1 15 0Z"
              />
            </svg>

            {openSidebar && <span>Add new point</span>}
          </button>

          <button
            onClick={() => setShowPointList(!showPointList)}
            className={`${openSidebar ? "h-10 w-full px-4" : "size-10  justify-center"} flex items-center gap-2 overflow-hidden rounded-xl bg-indigo-200 font-bold text-indigo-600 transition-all duration-300`}
          >
            {showPointList ? <EyeOff></EyeOff> : <Eye></Eye>}

            {openSidebar && (
              <span>
                {showPointList ? "Hide points list" : "Show points list"}
              </span>
            )}
          </button>
        </div>
      </div>
    </div>
  );
}

// File: src/components/ui/checkbox.tsx
/* eslint-disable react/prop-types */
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "focus-visible:ring-ring peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="size-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };

// File: src/components/ui/badge.tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

// File: src/components/ui/command.tsx
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

interface CommandDialogProps extends DialogProps {}

const CommandDialog = ({ children, ...props }: CommandDialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

// File: src/components/ui/accordion.tsx
/* eslint-disable react/prop-types */
"use client";

import * as React from "react";
import * as AccordionPrimitive from "@radix-ui/react-accordion";
import { ChevronDown } from "lucide-react";

import { cn } from "@/lib/utils";

const Accordion = AccordionPrimitive.Root;

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
));
AccordionItem.displayName = "AccordionItem";

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className,
      )}
      {...props}
    >
      {children}
      <ChevronDown className="size-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
));
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName;

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
));

AccordionContent.displayName = AccordionPrimitive.Content.displayName;

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent };

// File: src/components/ui/label.tsx
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

// File: src/components/ui/dialog.tsx
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

// File: src/components/ui/multiple-selector.tsx
/* eslint-disable react/prop-types */
"use client";

import { Command as CommandPrimitive, useCommandState } from "cmdk";
import { X } from "lucide-react";
import * as React from "react";
import { forwardRef, useEffect } from "react";

import { Badge } from "@/components/ui/badge";
import {
  Command,
  CommandGroup,
  CommandItem,
  CommandList,
} from "@/components/ui/command";
import { cn } from "@/lib/utils";

export interface Option {
  value: string;
  label: string;
  disable?: boolean;
  /** fixed option that can't be removed. */
  fixed?: boolean;
  /** Group the options by providing key. */
  [key: string]: string | boolean | undefined;
}
interface GroupOption {
  [key: string]: Option[];
}

interface MultipleSelectorProps {
  value?: Option[];
  defaultOptions?: Option[];
  /** manually controlled options */
  options?: Option[];
  placeholder?: string;
  /** Loading component. */
  loadingIndicator?: React.ReactNode;
  /** Empty component. */
  emptyIndicator?: React.ReactNode;
  /** Debounce time for async search. Only work with `onSearch`. */
  delay?: number;
  /**
   * Only work with `onSearch` prop. Trigger search when `onFocus`.
   * For example, when user click on the input, it will trigger the search to get initial options.
   **/
  triggerSearchOnFocus?: boolean;
  /** async search */
  onSearch?: (value: string) => Promise<Option[]>;
  /**
   * sync search. This search will not showing loadingIndicator.
   * The rest props are the same as async search.
   * i.e.: creatable, groupBy, delay.
   **/
  onSearchSync?: (value: string) => Option[];
  onChange?: (options: Option[]) => void;
  /** Limit the maximum number of selected options. */
  maxSelected?: number;
  /** When the number of selected options exceeds the limit, the onMaxSelected will be called. */
  onMaxSelected?: (maxLimit: number) => void;
  /** Hide the placeholder when there are options selected. */
  hidePlaceholderWhenSelected?: boolean;
  disabled?: boolean;
  /** Group the options base on provided key. */
  groupBy?: string;
  className?: string;
  badgeClassName?: string;
  /**
   * First item selected is a default behavior by cmdk. That is why the default is true.
   * This is a workaround solution by add a dummy item.
   *
   * @reference: https://github.com/pacocoursey/cmdk/issues/171
   */
  selectFirstItem?: boolean;
  /** Allow user to create option when there is no option matched. */
  creatable?: boolean;
  /** Props of `Command` */
  commandProps?: React.ComponentPropsWithoutRef<typeof Command>;
  /** Props of `CommandInput` */
  inputProps?: Omit<
    React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>,
    "value" | "placeholder" | "disabled"
  >;
  /** hide the clear all button. */
  hideClearAllButton?: boolean;
}

export interface MultipleSelectorRef {
  selectedValue: Option[];
  input: HTMLInputElement;
  focus: () => void;
  reset: () => void;
}

export function useDebounce<T>(value: T, delay?: number): T {
  const [debouncedValue, setDebouncedValue] = React.useState<T>(value);

  useEffect(() => {
    const timer = setTimeout(() => setDebouncedValue(value), delay || 500);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

function transToGroupOption(options: Option[], groupBy?: string) {
  if (options.length === 0) {
    return {};
  }
  if (!groupBy) {
    return {
      "": options,
    };
  }

  const groupOption: GroupOption = {};
  options.forEach((option) => {
    const key = (option[groupBy] as string) || "";
    if (!groupOption[key]) {
      groupOption[key] = [];
    }
    groupOption[key].push(option);
  });
  return groupOption;
}

function removePickedOption(groupOption: GroupOption, picked: Option[]) {
  const cloneOption = JSON.parse(JSON.stringify(groupOption)) as GroupOption;

  for (const [key, value] of Object.entries(cloneOption)) {
    cloneOption[key] = value.filter(
      (val) => !picked.find((p) => p.value === val.value),
    );
  }
  return cloneOption;
}

function isOptionsExist(groupOption: GroupOption, targetOption: Option[]) {
  for (const [, value] of Object.entries(groupOption)) {
    if (
      value.some((option) => targetOption.find((p) => p.value === option.value))
    ) {
      return true;
    }
  }
  return false;
}

/**
 * The `CommandEmpty` of shadcn/ui will cause the cmdk empty not rendering correctly.
 * So we create one and copy the `Empty` implementation from `cmdk`.
 *
 * @reference: https://github.com/hsuanyi-chou/shadcn-ui-expansions/issues/34#issuecomment-1949561607
 **/
const CommandEmpty = forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof CommandPrimitive.Empty>
>(({ className, ...props }, forwardedRef) => {
  const render = useCommandState((state) => state.filtered.count === 0);

  if (!render) {
    return null;
  }

  return (
    <div
      ref={forwardedRef}
      className={cn("py-6 text-center text-sm", className)}
      cmdk-empty=""
      role="presentation"
      {...props}
    />
  );
});

CommandEmpty.displayName = "CommandEmpty";

const MultipleSelector = React.forwardRef<
  MultipleSelectorRef,
  MultipleSelectorProps
>(
  (
    {
      value,
      onChange,
      placeholder,
      defaultOptions: arrayDefaultOptions = [],
      options: arrayOptions,
      delay,
      onSearch,
      onSearchSync,
      loadingIndicator,
      emptyIndicator,
      maxSelected = Number.MAX_SAFE_INTEGER,
      onMaxSelected,
      hidePlaceholderWhenSelected,
      disabled,
      groupBy,
      className,
      badgeClassName,
      selectFirstItem = true,
      creatable = false,
      triggerSearchOnFocus = false,
      commandProps,
      inputProps,
      hideClearAllButton = false,
    }: MultipleSelectorProps,
    ref: React.Ref<MultipleSelectorRef>,
  ) => {
    const inputRef = React.useRef<HTMLInputElement>(null);
    const [open, setOpen] = React.useState(false);
    const [onScrollbar, setOnScrollbar] = React.useState(false);
    const [isLoading, setIsLoading] = React.useState(false);
    const dropdownRef = React.useRef<HTMLDivElement>(null); // Added this

    const [selected, setSelected] = React.useState<Option[]>(value || []);
    const [options, setOptions] = React.useState<GroupOption>(
      transToGroupOption(arrayDefaultOptions, groupBy),
    );
    const [inputValue, setInputValue] = React.useState("");
    const debouncedSearchTerm = useDebounce(inputValue, delay || 500);

    React.useImperativeHandle(
      ref,
      () => ({
        selectedValue: [...selected],
        input: inputRef.current as HTMLInputElement,
        focus: () => inputRef?.current?.focus(),
        reset: () => setSelected([]),
      }),
      [selected],
    );

    const handleClickOutside = (event: MouseEvent | TouchEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node) &&
        inputRef.current &&
        !inputRef.current.contains(event.target as Node)
      ) {
        setOpen(false);
        inputRef.current.blur();
      }
    };

    const handleUnselect = React.useCallback(
      (option: Option) => {
        const newOptions = selected.filter((s) => s.value !== option.value);
        setSelected(newOptions);
        onChange?.(newOptions);
      },
      [onChange, selected],
    );

    const handleKeyDown = React.useCallback(
      (e: React.KeyboardEvent<HTMLDivElement>) => {
        const input = inputRef.current;
        if (input) {
          if (e.key === "Delete" || e.key === "Backspace") {
            if (input.value === "" && selected.length > 0) {
              const lastSelectOption = selected[selected.length - 1];
              // If last item is fixed, we should not remove it.
              if (!lastSelectOption.fixed) {
                handleUnselect(selected[selected.length - 1]);
              }
            }
          }
          // This is not a default behavior of the <input /> field
          if (e.key === "Escape") {
            input.blur();
          }
        }
      },
      [handleUnselect, selected],
    );

    useEffect(() => {
      if (open) {
        document.addEventListener("mousedown", handleClickOutside);
        document.addEventListener("touchend", handleClickOutside);
      } else {
        document.removeEventListener("mousedown", handleClickOutside);
        document.removeEventListener("touchend", handleClickOutside);
      }

      return () => {
        document.removeEventListener("mousedown", handleClickOutside);
        document.removeEventListener("touchend", handleClickOutside);
      };
    }, [open]);

    useEffect(() => {
      if (value) {
        setSelected(value);
      }
    }, [value]);

    useEffect(() => {
      /** If `onSearch` is provided, do not trigger options updated. */
      if (!arrayOptions || onSearch) {
        return;
      }
      const newOption = transToGroupOption(arrayOptions || [], groupBy);
      if (JSON.stringify(newOption) !== JSON.stringify(options)) {
        setOptions(newOption);
      }
    }, [arrayDefaultOptions, arrayOptions, groupBy, onSearch, options]);

    useEffect(() => {
      /** sync search */

      const doSearchSync = () => {
        const res = onSearchSync?.(debouncedSearchTerm);
        setOptions(transToGroupOption(res || [], groupBy));
      };

      const exec = async () => {
        if (!onSearchSync || !open) {
          return;
        }

        if (triggerSearchOnFocus) {
          doSearchSync();
        }

        if (debouncedSearchTerm) {
          doSearchSync();
        }
      };

      void exec();
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [debouncedSearchTerm, groupBy, open, triggerSearchOnFocus]);

    useEffect(() => {
      /** async search */

      const doSearch = async () => {
        setIsLoading(true);
        const res = await onSearch?.(debouncedSearchTerm);
        setOptions(transToGroupOption(res || [], groupBy));
        setIsLoading(false);
      };

      const exec = async () => {
        if (!onSearch || !open) {
          return;
        }

        if (triggerSearchOnFocus) {
          await doSearch();
        }

        if (debouncedSearchTerm) {
          await doSearch();
        }
      };

      void exec();
      // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [debouncedSearchTerm, groupBy, open, triggerSearchOnFocus]);

    const CreatableItem = () => {
      if (!creatable) {
        return undefined;
      }
      if (
        isOptionsExist(options, [{ value: inputValue, label: inputValue }]) ||
        selected.find((s) => s.value === inputValue)
      ) {
        return undefined;
      }

      const Item = (
        <CommandItem
          value={inputValue}
          className="cursor-pointer"
          onMouseDown={(e) => {
            e.preventDefault();
            e.stopPropagation();
          }}
          onSelect={(value: string) => {
            if (selected.length >= maxSelected) {
              onMaxSelected?.(selected.length);
              return;
            }
            setInputValue("");
            const newOptions = [...selected, { value, label: value }];
            setSelected(newOptions);
            onChange?.(newOptions);
          }}
        >
          {`Create "${inputValue}"`}
        </CommandItem>
      );

      // For normal creatable
      if (!onSearch && inputValue.length > 0) {
        return Item;
      }

      // For async search creatable. avoid showing creatable item before loading at first.
      if (onSearch && debouncedSearchTerm.length > 0 && !isLoading) {
        return Item;
      }

      return undefined;
    };

    const EmptyItem = React.useCallback(() => {
      if (!emptyIndicator) {
        return undefined;
      }

      // For async search that showing emptyIndicator
      if (onSearch && !creatable && Object.keys(options).length === 0) {
        return (
          <CommandItem value="-" disabled>
            {emptyIndicator}
          </CommandItem>
        );
      }

      return <CommandEmpty>{emptyIndicator}</CommandEmpty>;
    }, [creatable, emptyIndicator, onSearch, options]);

    const selectables = React.useMemo<GroupOption>(
      () => removePickedOption(options, selected),
      [options, selected],
    );

    /** Avoid Creatable Selector freezing or lagging when paste a long string. */
    const commandFilter = React.useCallback(() => {
      if (commandProps?.filter) {
        return commandProps.filter;
      }

      if (creatable) {
        return (value: string, search: string) => {
          return value.toLowerCase().includes(search.toLowerCase()) ? 1 : -1;
        };
      }
      // Using default filter in `cmdk`. We don't have to provide it.
      return undefined;
    }, [creatable, commandProps?.filter]);

    return (
      <Command
        ref={dropdownRef}
        {...commandProps}
        onKeyDown={(e) => {
          handleKeyDown(e);
          commandProps?.onKeyDown?.(e);
        }}
        className={cn(
          "h-auto overflow-visible bg-transparent",
          commandProps?.className,
        )}
        shouldFilter={
          commandProps?.shouldFilter !== undefined
            ? commandProps.shouldFilter
            : !onSearch
        } // When onSearch is provided, we don't want to filter the options. You can still override it.
        filter={commandFilter()}
      >
        <div
          className={cn(
            "border-input focus-within:ring-ring min-h-10 rounded-md border text-sm ring-offset-background focus-within:ring-2 focus-within:ring-offset-2",
            {
              "px-3 py-2": selected.length !== 0,
              "cursor-text": !disabled && selected.length !== 0,
            },
            className,
          )}
          onClick={() => {
            if (disabled) {
              return;
            }
            inputRef?.current?.focus();
          }}
        >
          <div className="relative flex flex-wrap gap-1">
            {selected.map((option) => {
              return (
                <Badge
                  key={option.value}
                  className={cn(
                    "data-[disabled]:bg-muted-foreground data-[disabled]:text-muted data-[disabled]:hover:bg-muted-foreground",
                    "data-[fixed]:bg-muted-foreground data-[fixed]:text-muted data-[fixed]:hover:bg-muted-foreground",
                    badgeClassName,
                  )}
                  data-fixed={option.fixed}
                  data-disabled={disabled || undefined}
                >
                  {option.label}
                  <button
                    className={cn(
                      "focus:ring-ring ml-1 rounded-full outline-none ring-offset-background focus:ring-2 focus:ring-offset-2",
                      (disabled || option.fixed) && "hidden",
                    )}
                    onKeyDown={(e) => {
                      if (e.key === "Enter") {
                        handleUnselect(option);
                      }
                    }}
                    onMouseDown={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                    }}
                    onClick={() => handleUnselect(option)}
                  >
                    <X className="text-muted-foreground size-3 hover:text-foreground" />
                  </button>
                </Badge>
              );
            })}
            {/* Avoid having the "Search" Icon */}
            <CommandPrimitive.Input
              {...inputProps}
              ref={inputRef}
              value={inputValue}
              disabled={disabled}
              onValueChange={(value) => {
                setInputValue(value);
                inputProps?.onValueChange?.(value);
              }}
              onBlur={(event) => {
                if (!onScrollbar) {
                  setOpen(false);
                }
                inputProps?.onBlur?.(event);
              }}
              onFocus={(event) => {
                setOpen(true);
                triggerSearchOnFocus && onSearch?.(debouncedSearchTerm);
                inputProps?.onFocus?.(event);
              }}
              placeholder={
                hidePlaceholderWhenSelected && selected.length !== 0
                  ? ""
                  : placeholder
              }
              className={cn(
                "placeholder:text-muted-foreground flex-1 bg-transparent outline-none",
                {
                  "w-full": hidePlaceholderWhenSelected,
                  "px-3 py-2": selected.length === 0,
                  "ml-1": selected.length !== 0,
                },
                inputProps?.className,
              )}
            />
            <button
              type="button"
              onClick={() => {
                setSelected(selected.filter((s) => s.fixed));
                onChange?.(selected.filter((s) => s.fixed));
              }}
              className={cn(
                "absolute right-0 h-6 w-6 p-0",
                (hideClearAllButton ||
                  disabled ||
                  selected.length < 1 ||
                  selected.filter((s) => s.fixed).length === selected.length) &&
                  "hidden",
              )}
            >
              <X />
            </button>
          </div>
        </div>
        <div className="relative">
          {open && (
            <CommandList
              className="bg-popover text-popover-foreground animate-in absolute top-1 z-20 w-full rounded-md border bg-white shadow-md outline-none"
              onMouseLeave={() => {
                setOnScrollbar(false);
              }}
              onMouseEnter={() => {
                setOnScrollbar(true);
              }}
              onMouseUp={() => {
                inputRef?.current?.focus();
              }}
            >
              {isLoading ? (
                <>{loadingIndicator}</>
              ) : (
                <>
                  {EmptyItem()}
                  {CreatableItem()}
                  {!selectFirstItem && (
                    <CommandItem value="-" className="hidden" />
                  )}
                  {Object.entries(selectables).map(([key, dropdowns]) => (
                    <CommandGroup
                      key={key}
                      heading={key}
                      className="h-full overflow-auto bg-white"
                    >
                      <>
                        {dropdowns.map((option) => {
                          return (
                            <CommandItem
                              key={option.value}
                              value={option.value}
                              disabled={option.disable}
                              onMouseDown={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                              }}
                              onSelect={() => {
                                if (selected.length >= maxSelected) {
                                  onMaxSelected?.(selected.length);
                                  return;
                                }
                                setInputValue("");
                                const newOptions = [...selected, option];
                                setSelected(newOptions);
                                onChange?.(newOptions);
                              }}
                              className={cn(
                                "cursor-pointer",
                                option.disable &&
                                  "text-muted-foreground cursor-default bg-white",
                              )}
                            >
                              {option.label}
                            </CommandItem>
                          );
                        })}
                      </>
                    </CommandGroup>
                  ))}
                </>
              )}
            </CommandList>
          )}
        </div>
      </Command>
    );
  },
);

MultipleSelector.displayName = "MultipleSelector";
export default MultipleSelector;

// File: src/components/forms/settingsForm.tsx
"use client";

import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { Button, Input, ModalBody, ModalFooter } from "@nextui-org/react";
import { useModal } from "@/store/useModal";
import { postData } from "@/services/API";
import { useAppStore } from "@/store/store";
import { settingsObject } from "@/validator";
export const SettingsForm = () => {
  const { setIsLoading, isLoading, setClose } = useModal((state) => state);
  const settings = useAppStore((state) => state.settings);
  const {
    register,
    handleSubmit,
    formState: { errors },
  } = useForm<z.infer<typeof settingsObject>>({
    resolver: zodResolver(settingsObject),
    mode: "onBlur",
    defaultValues: {
      lat_settings: settings?.lat || 35.694523130867424,
      lng_settings: settings?.lng || 51.30922197948697,
      zoom: settings?.zoom || 11,
    },
  });
  const submitHandler = async (data: z.infer<typeof settingsObject>) => {
    let svg: { name: string; url: string } | undefined;
    setIsLoading(true);
    const formData = new FormData();
    if (data?.file) {
      const file = data?.file[0];
      formData.append("file", file);
      const res = await fetch("/api/uploads/svg", {
        method: "POST",
        body: formData,
      });
      svg = await res.json();
    }
    if (!svg) {
      postData("/api/settings", {
        lat: data.lat_settings,
        lng: data.lng_settings,
        zoom: data.zoom || 11, // Ensure a default zoom is set if undefined
      })
        .then(() => {
          setIsLoading(false);
        })
        .catch(() => {
          setIsLoading(false);
        });
    } else {
      postData("/api/settings", {
        lat: data.lat_settings,
        lng: data.lng_settings,
        zoom: data.zoom || 11, // Ensure a default zoom is set if undefined
        PointIcon: [...((settings?.PointIcon as []) || []), svg],
      })
        .then(() => {
          setIsLoading(false);
        })
        .catch(() => {
          setIsLoading(false);
        });
    }
  };
  return (
    <form
      className="flex w-full flex-col gap-4"
      onSubmit={handleSubmit((x) => submitHandler(x))}
    >
      <ModalBody>
        <div className="flex w-full flex-col gap-4">
          <Input
            isRequired
            label="Lat"
            labelPlacement="outside"
            placeholder="Enter point lat"
            isInvalid={!!errors.lat_settings}
            errorMessage={
              errors.lat_settings ? errors.lat_settings.message : ""
            }
            {...register("lat_settings", {
              required: true,
              valueAsNumber: true,
            })}
          />

          <Input
            isRequired
            label="Lng"
            labelPlacement="outside"
            placeholder="Enter point lng"
            isInvalid={!!errors.lng_settings}
            errorMessage={
              errors.lng_settings ? errors.lng_settings.message : ""
            }
            {...register("lng_settings", {
              required: true,
              valueAsNumber: true,
            })}
          />

          <Input
            isRequired
            label="Zoom"
            labelPlacement="outside"
            placeholder="Enter map zoom"
            isInvalid={!!errors.zoom}
            errorMessage={errors.zoom ? errors.zoom.message : ""}
            {...register("zoom", { required: true, valueAsNumber: true })}
          />

          <Input
            type="file"
            accept=".svg"
            isInvalid={!!errors.file}
            errorMessage={errors.file ? errors.file.message : ""}
            {...register("file")}
          />
        </div>
      </ModalBody>
      <ModalFooter>
        <div className="flex w-full justify-center gap-4">
          <Button
            color="danger"
            variant="light"
            type="button"
            onClick={() => setClose()}
          >
            Close
          </Button>
          <Button
            isLoading={isLoading}
            variant="shadow"
            className="bg-green-600 text-white shadow-green-200"
            type="submit"
          >
            Save
          </Button>
        </div>
      </ModalFooter>
    </form>
  );
};

// File: src/components/forms/pointForm.tsx
"use client";

import { postData, putData } from "@/services/API";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { z } from "zod";
import { pointObject } from "@/validator";
import {
  Button,
  Input,
  ModalBody,
  ModalFooter,
  Select,
  SelectItem,
  Switch,
} from "@nextui-org/react";
import { useModal } from "@/store/useModal";
import { useAppStore } from "@/store/store";
import MultipleSelector, { Option } from "@/components/ui/multiple-selector";
import { Label } from "../ui/label";
const OPTIONS: Option[] = [
  { label: "frequency", value: "frequency" },
  { label: "angle", value: "angle" },
  { label: "status", value: "status" },
  { label: "bandwidth", value: "bandwidth" },
];
export const PointForm = ({ type }: { type?: "edit" | "create" }) => {
  const { data, setIsLoading, isLoading, setClose } = useModal(
    (state) => state,
  );
  const getAllPoints = useAppStore((state) => state.getAllPoints);
  const settings = useAppStore((state) => state.settings);
  const {
    register,
    handleSubmit,
    reset,
    setValue,
    formState: { errors },
  } = useForm<z.infer<typeof pointObject>>({
    resolver: zodResolver(pointObject),

    defaultValues: {
      name: data.point?.name || "",
      lat: data.point?.lat || 0,
      lng: data.point?.lng || 0,
      frequency: data.point?.frequency || 0,
      iconType: data.point?.iconType || "car", // مقدار پیش‌فرض برای آیکون
      active: data.point?.active || false,
      connect: data.point?.connect || false,
      status: data.point?.status || false,
      level: data.point?.level || 0,
    },
  });

  const submitHandler = (newPoint: z.infer<typeof pointObject>) => {
    if (type == "edit") {
      setIsLoading(true);
      putData("/api/points/", {
        ...newPoint,
        id: data.point?._id,
      })
        .then(() => {
          setIsLoading(false);
          getAllPoints();
          reset({
            name: "",
            lat: 0,
            lng: 0,
            frequency: 0,
            iconType: "car",
          });
          setClose();
        })
        .catch(() => {
          setIsLoading(false);
        });
    } else {
      setIsLoading(true);
      postData("/api/points", { ...newPoint })
        .then(() => {
          getAllPoints();
          setIsLoading(false);

          reset({
            name: "",
            lat: 0,
            lng: 0,
            frequency: 0,
            iconType: "car",
          });
          setClose();
        })
        .catch(() => {
          setIsLoading(false);
        });
    }
  };

  return (
    <>
      <form
        className="flex w-full flex-col gap-4"
        onSubmit={handleSubmit((x) => submitHandler(x))}
      >
        <ModalBody>
          <Input
            isRequired
            label="Name"
            className="text-lg font-semibold"
            labelPlacement="outside"
            placeholder="Enter point name"
            isInvalid={!!errors.name}
            errorMessage={errors.name ? errors.name.message : ""}
            {...register("name", { required: true })}
          />
          <Input
            isRequired
            label="Lat"
            className="text-lg font-semibold"
            labelPlacement="outside"
            placeholder="Enter point lat"
            isInvalid={!!errors.lat}
            errorMessage={errors.lat ? errors.lat.message : ""}
            {...register("lat", { required: true, valueAsNumber: true })}
          />
          <Input
            isRequired
            label="Lng"
            className="text-lg font-semibold"
            labelPlacement="outside"
            placeholder="Enter point lng"
            isInvalid={!!errors.lng}
            errorMessage={errors.lng ? errors.lng.message : ""}
            {...register("lng", { required: true, valueAsNumber: true })}
          />
          <Input
            isRequired
            label="Frequency"
            className="text-lg font-semibold"
            labelPlacement="outside"
            placeholder="Enter point frequency"
            isInvalid={!!errors.frequency}
            errorMessage={errors.frequency ? errors.frequency.message : ""}
            {...register("frequency", { required: true, valueAsNumber: true })}
          />
          <Input
            isRequired
            label="Level"
            labelPlacement="outside"
            className="text-lg font-semibold"
            placeholder="Enter point Level"
            isInvalid={!!errors.level}
            errorMessage={errors.level ? errors.level.message : ""}
            {...register("level", { required: true, valueAsNumber: true })}
          />{" "}
          <Input
            isRequired
            label="port"
            labelPlacement="outside"
            className="text-lg font-semibold"
            placeholder="Enter point port"
            isInvalid={!!errors.port}
            errorMessage={errors.port ? errors.port.message : ""}
            {...register("port", { required: true, valueAsNumber: true })}
          />
          {/* <MultipleSelector
            defaultOptions={OPTIONS}
            placeholder="Select frameworks you like..."
            className="bg-white"
            emptyIndicator={
              <p className="text-center text-lg leading-10 text-gray-600 dark:text-gray-400">
                no results found.
              </p>
            }
            onChange={(e) => {
              const data = e.map((e) => e.value);
              setValue("requireData", data);
            }}
          /> */}
          {/* Select for Icon Type */}
          <Select
            label="Choose Icon"
            placeholder="Select an icon"
            className="text-lg font-semibold "
            isRequired
            isInvalid={!!errors.iconType}
            errorMessage={errors.iconType ? errors.iconType.message : ""}
            {...register("iconType", { required: true })}
          >
            {settings?.PointIcon ? (
              settings?.PointIcon.map((val) => (
                <SelectItem key={val.name} value={val.name}>
                  {val.name}
                </SelectItem>
              ))
            ) : (
              <>
                <SelectItem key="car" value="car">
                  Car
                </SelectItem>
                <SelectItem key="plane" value="plane">
                  Plane
                </SelectItem>
                <SelectItem key="bus" value="bus">
                  Bus
                </SelectItem>
              </>
            )}
          </Select>
          <div className="flex items-center  gap-2">
            <Label htmlFor="status" className="text-sm font-semibold">
              status:
            </Label>
            <Switch
              id="status"
              {...register("status", { required: true })}
            ></Switch>
          </div>
          <div className="flex items-center  gap-2">
            <Label htmlFor="active" className="text-sm font-semibold">
              active:
            </Label>
            <Switch
              id="active"
              {...register("active", { required: true })}
            ></Switch>
          </div>
          <div className="flex items-center  gap-2">
            <Label htmlFor="connect" className="text-sm font-semibold">
              connect:
            </Label>
            <Switch
              id="connect"
              {...register("connect", { required: true })}
            ></Switch>
          </div>
        </ModalBody>

        <ModalFooter>
          <div className="flex w-full justify-center gap-4">
            <Button
              color="danger"
              variant="light"
              type="button"
              onClick={() => setClose()}
            >
              Close
            </Button>
            <Button
              isLoading={isLoading}
              variant="shadow"
              className="bg-green-600 text-white shadow-green-200"
              type="submit"
            >
              {type === "edit" ? "Edit Point" : "Add Point"}
            </Button>
          </div>
        </ModalFooter>
      </form>
    </>
  );
};

// File: src/services/API.ts
import axios from "axios";

const servicesApi = axios.create({
  withCredentials: false,
  timeout: 60000,
  headers: {
    common: {
      Accept: "application/json",
    },
  },
});

export const postData = async (
  param: string,
  data: any,
  withToken: boolean = false,
) => {
  if (withToken) {
    const token = localStorage.getItem("token");
    return servicesApi.post(param, data, {
      headers: { Authorization: `Bearer ${token}` },
    });
  }
  return servicesApi.post(param, data);
};
export const putData = async (
  param: string,
  data: any,
  withToken: boolean = false,
) => {
  if (withToken) {
    const token = localStorage.getItem("token");
    return servicesApi.put(param, data, {
      headers: { Authorization: `Bearer ${token}` },
    });
  }
  return servicesApi.put(param, data); // Use PUT instead of POST
};

export const getData = async (
  param: string,
  data: any,
  withToken: boolean = false,
) => {
  if (withToken) {
    const token = localStorage.getItem("token");
    return servicesApi.get(param, {
      params: data,
      headers: { Authorization: `Bearer ${token}` },
    });
  }
  return servicesApi.get(param, { params: data });
};

export const deleteData = async (
  param: string,
  data: any,
  withToken: boolean = false,
) => {
  if (withToken) {
    const token = localStorage.getItem("token");
    return servicesApi.delete(param, {
      headers: { Authorization: `Bearer ${token}` },
      data,
    });
  }
  return servicesApi.delete(param, { data });
};

// File: src/lib/utils.ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// File: src/providers/ModalProvider.tsx
"use client";
import React from "react";
import { useModal } from "@/store/useModal";

export const ModalProvider = () => {
  const Model = useModal((state) => state.modal);
  return <>{Model}</>;
};

// File: models/PolygonModel.ts
import mongoose from "mongoose";

const polygonSchema = new mongoose.Schema({
  name: { type: String, required: true },
  points: [{ lat: Number, lng: Number }], // Array of polygon vertices
  flag: { type: Number, default: 1 }, // 0 (hide) or 1 (show)
  isPolygon: { type: Boolean, default: true }, // True for polygons
  date: { type: Date, default: Date.now },
  deletedAt: { type: mongoose.Schema.Types.Mixed, default: null },
});
const PolygonsModel =
  mongoose.models.Polygons || mongoose.model("Polygons", polygonSchema);

export default PolygonsModel;

// File: models/LineModel.ts
// models/LineModel.ts
import mongoose from "mongoose";

// تعریف اسکیمای خط
const lineSchema = new mongoose.Schema({
  startPoint: {
    lat: { type: Number, required: true },
    lng: { type: Number, required: true },
  },
  endPoint: {
    lat: { type: Number, required: true },
    lng: { type: Number, required: true },
  },
  length: { type: Number, required: true }, // طول خط
  angle: { type: Number, required: true }, // زاویه خط
  createdAt: { type: Date, default: Date.now }, // تاریخ ایجاد خط
  createdBy: { type: mongoose.Schema.Types.ObjectId, ref: "User" }, // کاربری که خط را ایجاد کرده است (اختیاری)
  deletedAt: { type: Date, default: null }, // تاریخ حذف (برای حذف نرم)
});

// ایجاد مدل خط با استفاده از اسکیمای تعریف‌شده
const LineModel = mongoose.models.Lines || mongoose.model("Lines", lineSchema);

export default LineModel;

// File: models/DFModels.ts
import mongoose from "mongoose";

const DFSchema = new mongoose.Schema(
  {
    bRunState: { type: Boolean, default: false }, // true -> DF, false -> Stop
    bWideband: { type: Boolean, default: false }, // true -> Wideband, false -> Narrowband
    dFrequencyRF: { type: Number, required: true }, // RF Frequency
    dFrequencyStartScan: { type: Number, required: true }, // Start frequency of the scan
    dFrequencyStopScan: { type: Number, required: true }, // Stop frequency of the scan
    dBandwidthIF: { type: Number, required: true }, // Intermediate Frequency Bandwidth in MHz
    dBandwidthDF: { type: Number, required: true }, // DF Bandwidth
    bNormalModeDF: { type: Boolean, default: false }, // true -> Normal, false -> Continues
    bNormalModeDFMode: {
      type: String,
      enum: ["Normal", "Continues"],
      default: "Normal",
    }, // ModeDF enum
    dThresholdLevelDF: { type: Number }, // DF Threshold Level
    dThresholdQualityDF: { type: Number }, // DF Threshold Quality
    iAverageTimeDF: { type: Number }, // Average time in milliseconds
    bPreAmplifierRF: { type: Boolean, default: false }, // Pre-Amplifier RF status
    bPreAmplifierRFMode: { type: String, enum: ["OFF", "ON"], default: "OFF" }, // PreAmplifierRF enum
    bLongAntennaRF: { type: Boolean, default: false }, // Antenna RF status
    bLongAntennaRFMode: {
      type: String,
      enum: ["Short", "Long"],
      default: "Short",
    }, // AntennaRF enum
    iTunerModeRF: { type: Number }, // Tuner Mode RF
    iGainRF: { type: Number }, // Gain for RF
    bAutoGainIF: { type: String, enum: ["MGC", "AGC"], default: "MGC" }, // GainIF enum
    iManualGainIF: { type: Number }, // Manual Gain in dBm
    iAutoGainCtrlTime: { type: Number }, // Auto Gain Control time in milliseconds
    dMaxGainAgc: { type: Number }, // Max gain for AGC in dBm
    bAFC: { type: Boolean, default: false }, // AFC status
    bAFCMode: { type: String, enum: ["ON", "OFF"], default: "OFF" }, // AFC enum
    bVoiceState: { type: Boolean, default: false }, // Voice state
    bSquelchState: { type: Boolean, default: false }, // Squelch state
    bStateDenoising: { type: Boolean, default: false }, // Denoising state
    strDemodulation: { type: String, default: "AM" }, // Demodulation type (AM, FM, etc.)
    dBandwidthVoice: { type: Number }, // Voice bandwidth in KHz
    iBeatFreqOffset: { type: Number }, // Beat frequency offset in Hz
    dGainVoice: { type: Number }, // Gain for voice in dBm
    bClassifier: { type: Boolean, default: false }, // Classifier state
    iTimeHistoryCL: { type: Number }, // Time history for classifier in milliseconds
  },
  { timestamps: true },
);

const DF = mongoose.model("DF", DFSchema);
module.exports = DF;

// File: models/pointDataModel.ts
import mongoose from "mongoose";

const schema = new mongoose.Schema({
  data: { type: {}, require: true },
});

const PointsDataModel =
  mongoose.models.PointsData || mongoose.model("PointsData", schema);

export default PointsDataModel;

// File: models/SettingsModel.ts
import mongoose from "mongoose";

const schema = new mongoose.Schema({
  lat: { type: Number, required: true, default: 35.694523130867424 },
  lng: { type: Number, required: true, default: 51.30922197948697 },
  zoom: { type: Number, required: true, default: 13 },
  PointIcon: {
    type: [
      {
        name: { type: String, required: true },
        url: { type: String, required: true },
      },
    ],
    default: [
      { name: "car", url: "/assets/car.svg" },
      { name: "bus", url: "/assets/bus.svg" },
      { name: "plane", url: "/assets/plane.svg" },
    ],
  },
});

const SettingsModel =
  mongoose.models.Settings || mongoose.model("Settings", schema);

export default SettingsModel;

// File: models/pointsModel.ts
import mongoose from "mongoose";

const schema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
  },
  lat: {
    type: Number,
    required: true,
  },
  lng: {
    type: Number,
    required: true,
  },
  frequency: {
    type: Number,
    required: true,
  },
  status: {
    type: Boolean,
    default: false,
  },
  active: {
    type: Boolean,
    default: false,
  },
  connect: {
    type: Boolean,
    default: false,
  },
  level: {
    type: Number,
    required: true,
  },
  date: {
    type: Date,
    default: () => Date.now(),
  },
  requireData: {
    type: Array,
    default: [],
  },
  port: {
    type: Number,
    default: 5000,
  },
  iconType: {
    type: String,
  },
  workerStatus: { type: String, default: "inactive" },
  PointsData: [{ type: mongoose.Types.ObjectId, ref: "PointsData" }],
  deletedAt: {
    type: mongoose.Schema.Types.Mixed,
    default: null,
  },
});

const PointsModel = mongoose.models.Points || mongoose.model("Points", schema);

export default PointsModel;

// File: models/targetModel.ts
import mongoose from "mongoose";

const schema = new mongoose.Schema({
  dFrequency: { type: Number, required: true }, // Target frequency
  dAzimuth: { type: Number, required: true }, // Azimuth angle
  dLevel: { type: Number, required: true }, // Signal level
  dQuality: { type: Number, required: true, min: 0, max: 100 }, // Signal quality (0 to 100)
});

const TargetModel = mongoose.models.Target || mongoose.model("Target", schema);

export default TargetModel;

// File: configs/db.ts
import mongoose from "mongoose";

let isConnected = false; // Track the database connection status

export const connectDB = async () => {
  if (isConnected) {
    return;
  }
  try {
    if (!mongoose.connections[0].readyState) {
      await mongoose.connect(process.env.MONGO_URL!);
      isConnected = true;
      console.log("Database connected");
    }
  } catch (err) {
    console.error("Database connection error:", err);
    throw err; // Ensure error bubbles up
  }
};

